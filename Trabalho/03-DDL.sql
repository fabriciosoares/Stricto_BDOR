CREATE OR REPLACE TYPE BODY TP_FUNCIONARIO AS
	MEMBER FUNCTION GETSUMALLGRATIFICACOES RETURN NUMBER AS CONT INTEGER;
	TOTAL NUMBER(8,2);
	BEGIN
		TOTAL:=0;
		IF(SELF.GRATIFICACOES IS NOT NULL) THEN
			FOR CONT IN 1..SELF.GRATIFICACOES.COUNT LOOP
				TOTAL := TOTAL + SELF.GRATIFICACOES(CONT).VALOR;
			END LOOP;
		END IF;
		RETURN TOTAL;
	END GETSUMALLGRATIFICACOES;
	MEMBER FUNCTION GETTOTGRATIFICACOESBYANO(ANO IN INTEGER) RETURN NUMBER AS TOTAL NUMBER(8,2);
	BEGIN
		TOTAL:=0;
		IF(SELF.GRATIFICACOES IS NOT NULL AND UTL_COLL.IS_LOCATOR(SELF.GRATIFICACOES)) THEN
			SELECT SUM(G.VALOR) INTO TOTAL
			FROM TABLE(CAST(SELF.GRATIFICACOES AS NESTED_GRATIFICACAO)) G
			WHERE TO_CHAR(G.PERIODO,'YYYY')=TO_CHAR(ANO);
		END IF;
		RETURN TOTAL;
	END GETTOTGRATIFICACOESBYANO;
	MEMBER FUNCTION GETTOTGRATIFICACOESBYPERIODO(DATAINI IN DATE, DATAFIM IN DATE) RETURN NUMBER AS TOTAL NUMBER(8,2);
	BEGIN
		TOTAL := 0;
		IF (SELF.GRATIFICACOES IS NOT NULL AND UTL_COLL.IS_LOCATOR(SELF.GRATIFICACOES)) THEN
			SELECT SUM(G.VALOR) INTO TOTAL
			FROM TABLE(CAST(SELF.GRATIFICACOES AS NESTED_GRATIFICACAO)) G
			WHERE R(G.PERIODO,'DD/MM/YYYY') BETWEEN TO_CHAR(DATAINI,'DD/MM/YYYY') AND TO_CHAR(DATAFIM,'DD/MM/YYYY');
		END IF;
	END GETTOTGRATIFICACOESBYPERIODO;
		MEMBER FUNCTION GETTOTGRATIFICACOESBYMESANO(MES IN INTEGER,ANO IN INTEGER) RETURN NUMBER AS
		TOTAL NUMBER(8,2);
		MESANO VARCHAR2(8);
	BEGIN
		TOTAL := 0;
		IF(SELF.GRATIFICACOES IS NOT NULL AND UTL_COLL.IS_LOCATOR(SELF.GRATIFICACOES)) THEN
			MESANO := TO_CHAR(MES) || '/' || TO_CHAR(ANO);
			SELECT SUM(G.VALOR) INTO TOTAL 
			FROM TABLE(CAST(SELF.GRATIFICACOES AS NESTED_GRATIFICACAO)) G
			WHERE	TO_CHAR(G.PERIODO,'MM/YYYY') = MESANO;
		END IF;
	RETURN TOTAL;
	END GETTOTGRATIFICACOESBYMESANO;
	MEMBER FUNCTION GETCARGO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(455);
	BEGIN
		SELECT DEREF(F.REF_CARGO).GETINFO() INTO RETORNO
		FROM TB_FUNCIONARIO F
		WHERE SELF.MATRICULA=F.MATRICULA;
		RETURN RETORNO;
	END GETCARGO;
	MEMBER FUNCTION GETSTATUS RETURN VARCHAR2 AS
	RETORNO VARCHAR2(25);
	BEGIN
		IF(SELF.STATUS='A') THEN
			RETORNO:='ATIVO';
		ELSE
			RETORNO:='INATIVO';
		END IF;
		RETURN RETORNO;
	END GETSTATUS;
	MEMBER FUNCTION GETINFO RETURN VARCHAR2 AS RETORNO VARCHAR2(1255);
	INFOFUNC VARCHAR(550);
	BEGIN
		SELECT DEREF(F.REF_PESSOAFISICA).GETINFO() INTO INFOFUNC 
		FROM TB_FUNCIONARIO F 
		WHERE F.MATRICULA=SELF.MATRICULA;
		RETORNO := ' DATA DE ADMISSÃO: ' || TO_CHAR(SELF.DATAADMISSAO,'DD/MM/YYYY');
		RETORNO := RETORNO || ' MATRÍCULA: ' || TO_CHAR(SELF.MATRICULA);
		RETORNO := RETORNO || ' SALÁRIO: ' || TO_CHAR(SELF.SALARIO);
		RETORNO := RETORNO || ' STATUS: ' || TO_CHAR(SELF.GETSTATUS());
		RETORNO := RETORNO || ' DADOS DO FUNCIONÁRIO: ' || INFOFUNC;
		RETURN RETORNO;
	END GETINFO;
	MEMBER FUNCTION GETINFORESUMIDA RETURN VARCHAR2 AS RETORNO VARCHAR2(1255);
	NOMEFUNC VARCHAR2(50);
	BEGIN
		SELECT DEREF(F.REF_PESSOAFISICA).NOME INTO NOMEFUNC 
		FROM TB_FUNCIONARIO F 
		WHERE F.MATRICULA=SELF.MATRICULA;
		RETORNO:=' MATRÍCULA: '||TO_CHAR(SELF.MATRICULA)||' NOME DO FUNCIONÁRIO: '||NOMEFUNC;
		RETURN RETORNO;
	END GETINFORESUMIDA;
-------------
PAREI AQUI
-------------
	
	
	MEMBER FUNCTION GETINFOSUPERVISOR RETURN VARCHAR2 AS
	 RETORNO VARCHAR2(1255);
	 INFOSUPERVISOR VARCHAR2(550);
	BEGIN
	   SELECT DEREF(F.REF_SUPERVISOR).GETINFO() INTO INFOSUPERVISOR FROM TB_FUNCIONARIO F WHERE F.MATRICULA=SELF.MATRICULA;
	   RETORNO:=' DADOS DO SUPERVISOR: '||INFOSUPERVISOR;
	   RETURN RETORNO;
	END GETINFOSUPERVISOR;

	MEMBER FUNCTION POSSUISUPERVISOR RETURN BOOLEAN AS
	RETORNO BOOLEAN;

	REFFUNC REF TP_FUNCIONARIO;
	BEGIN

	  SELECT REF(F)  INTO REFFUNC
	  FROM TB_FUNCIONARIO F WHERE F.MATRICULA=SELF.MATRICULA AND (F.REF_SUPERVISOR IS NOT DANGLING);

	  IF(SELF.REF_SUPERVISOR IS NOT NULL AND REFFUNC IS NOT NULL) THEN
		 RETORNO:=TRUE;
	  ELSE
		 RETORNO:=FALSE;
	  END IF;
	 RETURN RETORNO;
	END POSSUISUPERVISOR;


	MEMBER FUNCTION GETFUNCIOARIOSSUPERVISIONADOS RETURN VARCHAR2 AS
	RETORNO VARCHAR2(2855);
	CONT NUMBER;
	CURSOR C_FSUPERVISIONADOS IS SELECT F.GETINFORESUMIDA() AS FUNC  FROM TB_FUNCIONARIO F
	WHERE (F.REF_SUPERVISOR IS NOT DANGLING AND F.REF_SUPERVISOR IS NOT NULL
	AND SELF.MATRICULA=DEREF(F.REF_SUPERVISOR).MATRICULA) ORDER BY (DEREF(F.REF_PESSOAFISICA).NOME);

	V_FSUPERVISIONADOS C_FSUPERVISIONADOS%ROWTYPE;



	BEGIN
	  RETORNO:='';
	  CONT:=0;
	  FOR V_FSUPERVISIONADOS IN C_FSUPERVISIONADOS LOOP
		CONT:=CONT+1;
		RETORNO:=RETORNO||' FUNCIONÁRIO SUPERVISIONADO '||TO_CHAR(CONT);
		RETORNO:=RETORNO||'ª - '||V_FSUPERVISIONADOS.FUNC;
	  END LOOP;

	 RETURN RETORNO;
	END GETFUNCIOARIOSSUPERVISIONADOS;


	MAP MEMBER FUNCTION GETMATRICULA RETURN NUMBER AS
	BEGIN
		RETURN SELF.MATRICULA;
	END GETMATRICULA;


	STATIC FUNCTION COMPARE(OBJ1 TP_FUNCIONARIO, OBJ2 TP_FUNCIONARIO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN
	  RETORNO:=FALSE;
	  IF(TO_CHAR(OBJ1.MATRICULA)=TO_CHAR(OBJ2.MATRICULA)) THEN
		RETORNO:=TRUE;
	  ELSE
		 RETORNO:=FALSE;
	  END IF;
	  RETURN RETORNO;
	END COMPARE;

END;
/

CREATE OR REPLACE TYPE BODY TP_HISTORICO_SETOR_FUNCIONARIO AS

	STATIC  FUNCTION GETHISTORICOFUNCIONARIO(MATRICULA IN NUMBER) RETURN VARCHAR2 AS
	  RETORNO VARCHAR2(32767);
	  CURSOR C_HISTFUN IS SELECT
	  TO_CHAR(H.DATAENTRADA,'DD/MM/YYYY HH:MI:SS') AS ENTRADA,
	  DEREF(H.REF_SETOR).DESCRICAO AS SETOR,
	  TO_CHAR(DEREF(H.REF_FUNCIONARIO).MATRICULA) AS MATRICULA,
	  H.REF_JORNADA.GETINFO() AS JORNADA
	  FROM TB_HISTORICO_SETOR_FUNCIONARIO H WHERE DEREF(H.REF_FUNCIONARIO).MATRICULA=MATRICULA  ORDER BY H.DATAENTRADA DESC;

	V_HISTFUN C_HISTFUN%ROWTYPE;
	BEGIN
	  RETORNO:='MATRICULA: '||TO_CHAR(MATRICULA)||CHR(13);

	  FOR V_HISTFUN IN C_HISTFUN LOOP
		RETORNO:=RETORNO||' SETOR: '||V_HISTFUN.SETOR||' DATA DE ENTRADA: '||V_HISTFUN.ENTRADA||CHR(13);
		RETORNO:=RETORNO||' SETOR: '||V_HISTFUN.SETOR||' DATA DE ENTRADA: '||V_HISTFUN.ENTRADA||CHR(13);
		RETORNO:=RETORNO||V_HISTFUN.JORNADA||CHR(13);
	  END LOOP;

	  RETURN RETORNO;
	END GETHISTORICOFUNCIONARIO;


	STATIC  FUNCTION GETSETORRECENTEFUNCIONARIO(P_MATRICULA IN NUMBER) RETURN VARCHAR2 AS
	   SETORRECENTE VARCHAR2(32767);
	   JORNADA VARCHAR2(32767);
	BEGIN
	  SELECT
	  -- TO_CHAR(H.DATAENTRADA,'DD/MM/YYYY HH:MI:SS') AS ENTRADA,
	  DEREF(H.REF_SETOR).DESCRICAO AS SETOR,
	  H.REF_JORNADA.GETINFO()
	  --, TO_CHAR(DEREF(H.REF_FUNCIONARIO).MATRICULA) AS MATRICULA
	  INTO SETORRECENTE, JORNADA
	  FROM TB_HISTORICO_SETOR_FUNCIONARIO H WHERE DEREF(H.REF_FUNCIONARIO).MATRICULA=P_MATRICULA
	  AND  H.DATAENTRADA=(SELECT MAX(H2.DATAENTRADA) AS ULTIMADTENTRADA FROM TB_HISTORICO_SETOR_FUNCIONARIO H2 WHERE DEREF(H2.REF_FUNCIONARIO).MATRICULA=P_MATRICULA);

	  IF(SETORRECENTE IS NOT NULL) THEN
		 SETORRECENTE:='SETOR RECENTE: '||TO_CHAR(SETORRECENTE)||CHR(13);
		 SETORRECENTE:=SETORRECENTE||JORNADA;
	  ELSE
		 SETORRECENTE:='SETOR RECENTE: <NENHUM>';
	  END IF;

	  RETURN SETORRECENTE;
	END GETSETORRECENTEFUNCIONARIO;


	STATIC FUNCTION GETFUNCIONARIOSDOSETOR(DESCSETOR IN VARCHAR2) RETURN VARCHAR2 AS
	RETORNO VARCHAR2(32767);
	CURSOR C_HISTFUNSETOR IS --PEGA OS FUNCIONARIOS DE UM DADO SETOR
	  SELECT DISTINCT
		DEREF(H.REF_FUNCIONARIO).MATRICULA AS MATRICULA,
		DEREF(DEREF(H.REF_FUNCIONARIO).REF_PESSOAFISICA).NOME AS FUNCIONARIO,
		TO_CHAR(H.DATAENTRADA,'DD/MM/YYYY HH:MI:SS') AS ENTRADA
	  FROM
		TB_HISTORICO_SETOR_FUNCIONARIO H
	  WHERE
	   DEREF(H.REF_SETOR).DESCRICAO=DESCSETOR
	   AND  H.DATAENTRADA=( SELECT MAX(H2.DATAENTRADA) AS ULTIMADTENTRADA
							FROM TB_HISTORICO_SETOR_FUNCIONARIO H2
							WHERE
							 DEREF(H2.REF_FUNCIONARIO).MATRICULA=DEREF(H.REF_FUNCIONARIO).MATRICULA
							 --AND DEREF(H2.REF_SETOR).DESCRICAO=DESCSETOR
						   );

	V_HISTFUNSETOR C_HISTFUNSETOR%ROWTYPE;
	BEGIN
	  RETORNO:='SETOR: '||DESCSETOR||CHR(13);

	  FOR V_HISTFUNSETOR IN C_HISTFUNSETOR LOOP
		RETORNO:=RETORNO||' MATRÍCULA: '||V_HISTFUNSETOR.MATRICULA||' FUNCIONÁRIO: '||V_HISTFUNSETOR.FUNCIONARIO||CHR(13)||
		' DATA DE ENTRADA: '||V_HISTFUNSETOR.ENTRADA||CHR(13);
	  END LOOP;

	  RETURN RETORNO;
	END GETFUNCIONARIOSDOSETOR;


	ORDER MEMBER FUNCTION EQUALS(OBJ TP_HISTORICO_SETOR_FUNCIONARIO) RETURN NUMBER AS
	COD INTEGER;
	BEGIN
	IF(SELF.DATAENTRADA=OBJ.DATAENTRADA) THEN
	   COD:=0;--IGUAL
	ELSIF(SELF.DATAENTRADA>OBJ.DATAENTRADA) THEN
	   COD:=-1;--DATA DO OBJETO É MENOR
	ELSE
	   COD:=1;--DATA DO OBJETO É MAIOR
	END IF;
	  RETURN  COD;-- ZERO: SELF > OBJ | NEGATIVO: SELF < OBJ | POSITIVO: SELF > OBJ
	END EQUALS;

	STATIC FUNCTION COMPARE(OBJ1 TP_HISTORICO_SETOR_FUNCIONARIO, OBJ2 TP_HISTORICO_SETOR_FUNCIONARIO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN
	  RETORNO:=FALSE;
	  IF(TO_CHAR(OBJ1.DATAENTRADA,'DD/MM/YYYY/ HH:MI:SS')=TO_CHAR(OBJ2.DATAENTRADA,'DD/MM/YYYY/ HH:MI:SS')) THEN
		RETORNO:=TRUE;
	  ELSE
		 RETORNO:=FALSE;
	  END IF;
	  RETURN RETORNO;
	END COMPARE;


	CONSTRUCTOR FUNCTION TP_HISTORICO_SETOR_FUNCIONARIO(MATRICULA IN NUMBER, DESCSETOR IN VARCHAR2,DESCJORNADA IN VARCHAR2)  RETURN SELF AS RESULT AS
	REFSETOR REF TP_SETOR;
	REFFUNCIONARIO REF TP_FUNCIONARIO;
	REFJORNADA REF TP_JORNADA;
	V_MATRICULA NUMBER;
	BEGIN
	  V_MATRICULA := MATRICULA;
	  SELF.DATAENTRADA:=SYSTIMESTAMP;

	  SELECT REF(S) INTO REFSETOR FROM TB_SETOR S WHERE S.DESCRICAO=DESCSETOR;
	  SELF.REF_SETOR:=REFSETOR;

	  SELECT REF(F) INTO REFFUNCIONARIO FROM TB_FUNCIONARIO F WHERE F.MATRICULA=V_MATRICULA;
	  SELF.REF_FUNCIONARIO:=REFFUNCIONARIO;

	  SELECT REF(J) INTO REFJORNADA FROM TB_JORNADA J WHERE J.DESCRICAO=DESCJORNADA;
	  SELF.REF_JORNADA:=REFJORNADA;

	  RETURN;
	END TP_HISTORICO_SETOR_FUNCIONARIO;


	CONSTRUCTOR FUNCTION TP_HISTORICO_SETOR_FUNCIONARIO(MATRICULA IN NUMBER, DESCSETOR IN VARCHAR2, DESCJORNADA IN VARCHAR2, MOMENTOENTRADA IN TIMESTAMP) RETURN SELF AS RESULT AS
	REFSETOR REF TP_SETOR;
	REFFUNCIONARIO REF TP_FUNCIONARIO;
	REFJORNADA REF TP_JORNADA;
	 V_MATRICULA NUMBER;
	BEGIN
	  V_MATRICULA:=MATRICULA;
	  SELF.DATAENTRADA:=MOMENTOENTRADA;

	  SELECT REF(S) INTO REFSETOR FROM TB_SETOR S WHERE S.DESCRICAO=DESCSETOR;
	  SELF.REF_SETOR:=REFSETOR;

	  SELECT REF(F) INTO REFFUNCIONARIO FROM TB_FUNCIONARIO F WHERE F.MATRICULA=V_MATRICULA;
	  SELF.REF_FUNCIONARIO:=REFFUNCIONARIO;

	  SELECT REF(J) INTO REFJORNADA FROM TB_JORNADA J WHERE J.DESCRICAO=DESCJORNADA;
	  SELF.REF_JORNADA:=REFJORNADA;

	  RETURN;
	END TP_HISTORICO_SETOR_FUNCIONARIO;

END;
/

CREATE OR REPLACE TYPE BODY TP_TIPOSERVICO AS


	MEMBER FUNCTION GETDESCRICAO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(855);
	BEGIN
	   SELECT
			   SELF.DESCRICAO
	   INTO RETORNO FROM DUAL;
	   RETURN RETORNO;
	END GETDESCRICAO;

	MEMBER FUNCTION GETINFO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(855);
	BEGIN
	   SELECT
	   ' CÓDIGO DO TIPO DO SERVIÇO: '||TO_CHAR(SELF.COD)||
	   ' DESCRIÇÃO: '||(SELF.DESCRICAO)
	   INTO RETORNO FROM DUAL;
	   RETURN RETORNO;
	END GETINFO;

	ORDER MEMBER FUNCTION EQUALS(OBJ TP_TIPOSERVICO) RETURN NUMBER AS
	BEGIN
	  RETURN  (SELF.COD  - OBJ.COD);-- ZERO: SELF > OBJ | NEGATIVO: SELF < OBJ | POSITIVO: SELF > OBJ
	END EQUALS;

	STATIC FUNCTION COMPARE(OBJ1 TP_TIPOSERVICO, OBJ2 TP_TIPOSERVICO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN

	  RETORNO:=FALSE;

	  IF(TO_CHAR(OBJ1.COD)=TO_CHAR(OBJ2.COD)OR(OBJ1.DESCRICAO=OBJ2.DESCRICAO)) THEN
		RETORNO:=TRUE;
	  ELSE
		RETORNO:=FALSE;
	  END IF;

	  RETURN RETORNO;
	END COMPARE;


	CONSTRUCTOR FUNCTION TP_TIPOSERVICO(DESCRICAO IN VARCHAR2) RETURN SELF AS RESULT AS
	BEGIN
	  SELF.COD:=SEQ_TIPOSERVICO.NEXTVAL;
	  SELF.DESCRICAO:=DESCRICAO;
	  RETURN;
	END TP_TIPOSERVICO;

END;


/
CREATE OR REPLACE TYPE BODY TP_SERVICO AS

	MEMBER FUNCTION GETINFO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(1855);
	BEGIN
	   SELECT
	   ' CÓDIGO DO SERVIÇO: '||TO_CHAR(SELF.COD)||
	   ' DESCRIÇÃO: '||(SELF.DESCRICAO)||
	   ' VALOR: '||TO_CHAR(SELF.VALOR)||
	   ' TIPO: '||DEREF(SELF.REF_TIPOSERVICO).GETDESCRICAO()
	   INTO RETORNO FROM DUAL;
	   RETURN RETORNO;
	END GETINFO;

	ORDER MEMBER FUNCTION EQUALS(OBJ TP_SERVICO) RETURN NUMBER AS
	BEGIN
	  RETURN  (SELF.COD  - OBJ.COD);-- ZERO: SELF > OBJ | NEGATIVO: SELF < OBJ | POSITIVO: SELF > OBJ
	END EQUALS;

	STATIC FUNCTION COMPARE(OBJ1 TP_SERVICO, OBJ2 TP_SERVICO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN

	  RETORNO:=FALSE;

	  IF(TO_CHAR(OBJ1.COD)=TO_CHAR(OBJ2.COD)OR(OBJ1.DESCRICAO=OBJ2.DESCRICAO)) THEN
		RETORNO:=TRUE;
	  ELSE
		RETORNO:=FALSE;
	  END IF;

	  RETURN RETORNO;
	END COMPARE;

	CONSTRUCTOR FUNCTION TP_SERVICO(DESCRICAO IN VARCHAR2, VALOR IN NUMBER, DESCTIPO IN VARCHAR2) RETURN SELF AS RESULT AS
	BEGIN
	  SELF.COD:=SEQ_SERVICO.NEXTVAL;
	  SELF.DESCRICAO:=DESCRICAO;
	  SELF.VALOR:=VALOR;
	  SELECT REF(TS) INTO SELF.REF_TIPOSERVICO FROM TB_TIPOSERVICO TS WHERE TS.DESCRICAO=DESCTIPO;
	  RETURN;
	END TP_SERVICO;

END;
/
CREATE OR REPLACE TYPE BODY TP_DESCONTO AS


	MEMBER FUNCTION GETDESCRICAO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(855);
	BEGIN
	   SELECT
			   SELF.DESCRICAO
	   INTO RETORNO FROM DUAL;
	   RETURN RETORNO;
	END GETDESCRICAO;

	MEMBER FUNCTION GETINFO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(855);
	BEGIN
	   SELECT
	   ' DESCRIÇÃO: '||(SELF.DESCRICAO)||
	   ' VALOR: '||TO_CHAR(SELF.VALOR)
	   INTO RETORNO FROM DUAL;
	   RETURN RETORNO;
	END GETINFO;

	ORDER MEMBER FUNCTION EQUALS(OBJ TP_DESCONTO) RETURN NUMBER AS
	BEGIN
	  RETURN  (SELF.COD  - OBJ.COD);-- ZERO: SELF > OBJ | NEGATIVO: SELF < OBJ | POSITIVO: SELF > OBJ
	END EQUALS;

	STATIC FUNCTION COMPARE(OBJ1 TP_DESCONTO, OBJ2 TP_DESCONTO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN

	  RETORNO:=FALSE;

	  IF(TO_CHAR(OBJ1.COD)=TO_CHAR(OBJ2.COD)OR(OBJ1.DESCRICAO=OBJ2.DESCRICAO)OR(OBJ1.VALOR=OBJ2.VALOR)) THEN
		RETORNO:=TRUE;
	  ELSE
		RETORNO:=FALSE;
	  END IF;

	  RETURN RETORNO;
	END COMPARE;

	CONSTRUCTOR FUNCTION TP_DESCONTO(DESCRICAO IN VARCHAR2, VALOR IN NUMBER) RETURN SELF AS RESULT AS
	BEGIN
	  SELF.COD:=SEQ_DESCONTO.NEXTVAL;
	  SELF.DESCRICAO:=DESCRICAO;
	  SELF.VALOR:=VALOR;
	  RETURN;
	END TP_DESCONTO;

END;
/
CREATE OR REPLACE TYPE BODY TP_LIVRO AS


	MEMBER FUNCTION GETDESCRICAO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(855);
	BEGIN
	   SELECT
			   SELF.DESCRICAO
	   INTO RETORNO FROM DUAL;
	   RETURN RETORNO;
	END GETDESCRICAO;

	MEMBER FUNCTION GETINFO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(855);
	BEGIN
	   SELECT
	   ' DESCRIÇÃO: '||(SELF.DESCRICAO)
	   INTO RETORNO FROM DUAL;
	   RETURN RETORNO;
	END GETINFO;

	ORDER MEMBER FUNCTION EQUALS(OBJ TP_LIVRO) RETURN NUMBER AS
	BEGIN
	  RETURN  (SELF.COD  - OBJ.COD);-- ZERO: SELF > OBJ | NEGATIVO: SELF < OBJ | POSITIVO: SELF > OBJ
	END EQUALS;

	STATIC FUNCTION COMPARE(OBJ1 TP_LIVRO, OBJ2 TP_LIVRO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN

	  RETORNO:=FALSE;

	  IF(TO_CHAR(OBJ1.COD)=TO_CHAR(OBJ2.COD)OR(OBJ1.DESCRICAO=OBJ2.DESCRICAO)) THEN
		RETORNO:=TRUE;
	  ELSE
		RETORNO:=FALSE;
	  END IF;

	  RETURN RETORNO;
	END COMPARE;

	CONSTRUCTOR FUNCTION TP_LIVRO(DESCRICAO IN VARCHAR2) RETURN SELF AS RESULT AS
	BEGIN
	  SELF.COD:=SEQ_LIVRO.NEXTVAL;
	  SELF.DESCRICAO:=DESCRICAO;
	  RETURN;
	END TP_LIVRO;

END;
/
CREATE OR REPLACE TYPE BODY TP_ATENDIMENTO AS

	MEMBER FUNCTION GETVALORTOTALATENDIMENTO RETURN NUMBER AS
	PRAGMA AUTONOMOUS_TRANSACTION;
	  V_TOTALATENDIMENTO NUMBER(8,2);
	BEGIN
		SELECT SUM(SA.VALORSERVICOREALIZADO) AS TOTAL INTO V_TOTALATENDIMENTO FROM TB_SERVICODOATENDIMENTO SA
		WHERE SA.REF_ATENDIMENTO.COD=SELF.COD;

		IF(V_TOTALATENDIMENTO IS NULL) THEN
		 V_TOTALATENDIMENTO:=0;
		END IF;

		COMMIT;
		RETURN V_TOTALATENDIMENTO;
	END GETVALORTOTALATENDIMENTO;

	MEMBER FUNCTION GETINFO RETURN VARCHAR2 AS
	 RETORNO VARCHAR2(32767);
	 INFOCLIENTE VARCHAR(32767);
	 INFOATENDENTE VARCHAR(32767);
	 V_TOTATENDIMENTO NUMBER(8,2);
	BEGIN

	   SELECT
	   DEREF(TA.REF_ATENDENTE).GETINFORESUMIDA(), DEREF(TA.REF_CLIENTE).GETINFO(), TA.GETVALORTOTALATENDIMENTO()
	   INTO INFOATENDENTE, INFOCLIENTE, V_TOTATENDIMENTO FROM TB_ATENDIMENTO TA WHERE TA.COD=SELF.COD;

	   RETORNO:='CÓDIGO DO ATENDIMENTO: '||TO_CHAR(SELF.COD)||
	   ' / DATA DO ATENDIMENTO: '||TO_CHAR(SELF.DATAATENDIMENTO,'DD/MM/YYYY')||CHR(13);
	   RETORNO:=RETORNO||' ATENDENTE: '||INFOATENDENTE||CHR(13);
	   RETORNO:=RETORNO||' CLIENTE: '||INFOCLIENTE||CHR(13);
	   RETORNO:=RETORNO||' VALOR TOTAL: '||TO_CHAR(V_TOTATENDIMENTO);

	   RETURN RETORNO;
	END GETINFO;


	MEMBER FUNCTION GETATENDENTE RETURN VARCHAR2 AS
	V_NOMEATENDENTE VARCHAR2(450);
	BEGIN
	  SELECT DEREF(TA.REF_ATENDENTE.REF_PESSOAFISICA).NOME AS NOMEATENDENTE INTO V_NOMEATENDENTE FROM TB_ATENDIMENTO TA
	  WHERE TA.COD=SELF.COD;
	  RETURN V_NOMEATENDENTE;
	END GETATENDENTE;

	MEMBER FUNCTION GETCLIENTE RETURN VARCHAR2 AS
	V_NOMECLIENTE VARCHAR2(450);
	BEGIN
	  SELECT DEREF(TA.REF_CLIENTE.REF_CLIENTE).NOME AS NOMECLIENTE INTO V_NOMECLIENTE FROM TB_ATENDIMENTO TA WHERE TA.COD=SELF.COD;
	  RETURN V_NOMECLIENTE;
	END GETCLIENTE;

	MAP MEMBER FUNCTION GETCOD RETURN NUMBER AS
	BEGIN
		RETURN SELF.COD;
	END GETCOD;


	STATIC FUNCTION COMPARE(OBJ1 TP_ATENDIMENTO, OBJ2 TP_ATENDIMENTO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN
	  RETORNO:=FALSE;
	  IF(TO_CHAR(OBJ1.COD)=TO_CHAR(OBJ2.COD)) THEN
		RETORNO:=TRUE;
	  ELSE
		 RETORNO:=FALSE;
	  END IF;
	  RETURN RETORNO;
	END COMPARE;


	--CONSTRUTOR PARA CADASTRAR UM FUNCIONARIO SEM GRATIFICACOES E SEM SUPERVISOR
	CONSTRUCTOR FUNCTION TP_ATENDIMENTO(V_CPF_CNPJCLIENTE IN VARCHAR2, V_CPFFUNCIONARIOATENDENTE IN VARCHAR2) RETURN SELF AS RESULT AS
	DATAATENDIMENTO_INVALIDO EXCEPTION;
	BEGIN

		SELF.DATAATENDIMENTO:=SYSTIMESTAMP;
		SELF.COD:=SEQ_ATENDIMENTO.NEXTVAL;
		SELF.VALORTOTAL:=0.0;

		IF(VALIDA_CNPJ(V_CPF_CNPJCLIENTE)='SIM') THEN
			--PEGA SOMENTE O CLIENTE PESSOA JURIDICA
			SELECT REF(CA) INTO SELF.REF_CLIENTE FROM TB_CLIENTE CA
			WHERE (DEREF(CA.REF_CLIENTE)IS OF(ONLY TP_JURIDICA)) AND (TREAT(DEREF(CA.REF_CLIENTE) AS TP_JURIDICA).CNPJ=V_CPF_CNPJCLIENTE);
		ELSIF(VALIDA_CPF(V_CPF_CNPJCLIENTE)='SIM') THEN
			--PEGA SOMENTE O CLIENTE PESSOA FISICA
			SELECT REF(CA) INTO SELF.REF_CLIENTE FROM TB_CLIENTE CA
			WHERE (DEREF(CA.REF_CLIENTE)IS OF(ONLY TP_FISICA)) AND (TREAT(DEREF(CA.REF_CLIENTE) AS TP_FISICA).CPF=V_CPF_CNPJCLIENTE);
		END IF;

		SELECT REF(AA) INTO SELF.REF_ATENDENTE FROM TB_FUNCIONARIO AA
		WHERE AA.REF_PESSOAFISICA.CPF=V_CPFFUNCIONARIOATENDENTE AND AA.REF_CARGO.DESCRICAO='ATENDENTE';

		IF(SELF.REF_ATENDENTE IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20011, 'FUNCIONÁRIO INVÁLIDO! INFORME UM FUNCIONÁRIO COM O CARGO DE ATENDENTE VÁLIDO PARA ATENDER O CLIENTE NO CARTÓRIO!');
			ELSIF(SELF.REF_CLIENTE IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20012, 'CLIENTE INVÁLIDO! INFORME UM CLIENTE COM CPF OU CNPJ VÁLIDO CADASTRADO NO CARTÓRIO!');
			ELSIF(SELF.DATAATENDIMENTO IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20013, 'DATA DE ATENDIMENTO INVÁLIDA! INFORME UMA DATA VÁLIDA PARA O ATENDIMENTO NO CARTÓRIO!');
			END IF;

	  RETURN;
	END TP_ATENDIMENTO;



	  CONSTRUCTOR FUNCTION TP_ATENDIMENTO(V_CPF_CNPJCLIENTE IN VARCHAR2, V_CPFFUNCIONARIOATENDENTE IN VARCHAR2, V_DATAATENDIMENTO IN TIMESTAMP) RETURN SELF AS RESULT AS
		  DATAATENDIMENTO_INVALIDO EXCEPTION;
		CLIENTE_INVALIDO EXCEPTION;
		 ATENDENTE_INVALIDO EXCEPTION;

	  BEGIN
		  SELF.DATAATENDIMENTO:=V_DATAATENDIMENTO;
		  SELF.COD:=SEQ_ATENDIMENTO.NEXTVAL;
		  SELF.VALORTOTAL:=0.0;

		  IF(VALIDA_CNPJ(V_CPF_CNPJCLIENTE)='SIM') THEN
			  --PEGA SOMENTE O CLIENTE PESSOA JURIDICA
			  SELECT REF(CA) INTO SELF.REF_CLIENTE FROM TB_CLIENTE CA
			  WHERE (DEREF(CA.REF_CLIENTE)IS OF(ONLY TP_JURIDICA)) AND (TREAT(DEREF(CA.REF_CLIENTE) AS TP_JURIDICA).CNPJ=V_CPF_CNPJCLIENTE);
		  ELSIF(VALIDA_CPF(V_CPF_CNPJCLIENTE)='SIM') THEN
			  --PEGA SOMENTE O CLIENTE PESSOA FISICA
			  SELECT REF(CA) INTO SELF.REF_CLIENTE FROM TB_CLIENTE CA
			  WHERE (DEREF(CA.REF_CLIENTE)IS OF(ONLY TP_FISICA)) AND (TREAT(DEREF(CA.REF_CLIENTE) AS TP_FISICA).CPF=V_CPF_CNPJCLIENTE);
		  END IF;

		  SELECT REF(AA) INTO SELF.REF_ATENDENTE FROM TB_FUNCIONARIO AA
		  WHERE AA.REF_PESSOAFISICA.CPF=V_CPFFUNCIONARIOATENDENTE AND AA.REF_CARGO.DESCRICAO='ATENDENTE';

			IF(SELF.REF_ATENDENTE IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20011, 'FUNCIONÁRIO INVÁLIDO! INFORME UM FUNCIONÁRIO COM O CARGO DE ATENDENTE VÁLIDO PARA ATENDER O CLIENTE NO CARTÓRIO!');
			ELSIF(SELF.REF_CLIENTE IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20012, 'CLIENTE INVÁLIDO! INFORME UM CLIENTE COM CPF OU CNPJ VÁLIDO CADASTRADO NO CARTÓRIO!');
			ELSIF(SELF.DATAATENDIMENTO IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20013, 'DATA DE ATENDIMENTO INVÁLIDA! INFORME UMA DATA VÁLIDA PARA O ATENDIMENTO NO CARTÓRIO!');
			END IF;


	  RETURN;

	  END TP_ATENDIMENTO;


	  CONSTRUCTOR FUNCTION TP_ATENDIMENTO(COD IN NUMBER, DATAATENDIMENTO IN TIMESTAMP, VALORTOTAL IN NUMBER, REF_ATENDENTE IN REF TP_FUNCIONARIO, REF_CLIENTE IN REF TP_CLIENTE) RETURN SELF AS RESULT AS
	  V_REFATENDENTE REF TP_FUNCIONARIO;
	  BEGIN
		  V_REFATENDENTE:=REF_ATENDENTE;

		  SELF.COD:=SEQ_ATENDIMENTO.NEXTVAL;
		  SELF.DATAATENDIMENTO:=DATAATENDIMENTO;
		  SELF.REF_CLIENTE:=REF_CLIENTE;
		  SELF.VALORTOTAL:=SELF.GETVALORTOTALATENDIMENTO();


		  SELECT REF(FA) INTO SELF.REF_ATENDENTE FROM TB_FUNCIONARIO FA WHERE FA.REF_CARGO.DESCRICAO='ATENDENTE'
		  AND REF(FA)=V_REFATENDENTE;

		  IF(SELF.REF_ATENDENTE IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20011, 'FUNCIONÁRIO INVÁLIDO! INFORME UM FUNCIONÁRIO COM O CARGO DE ATENDENTE VÁLIDO PARA ATENDER O CLIENTE NO CARTÓRIO!');
			ELSIF(SELF.REF_CLIENTE IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20012, 'CLIENTE INVÁLIDO! INFORME UM CLIENTE COM CPF OU CNPJ VÁLIDO CADASTRADO NO CARTÓRIO!');
			ELSIF(SELF.DATAATENDIMENTO IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20013, 'DATA DE ATENDIMENTO INVÁLIDA! INFORME UMA DATA VÁLIDA PARA O ATENDIMENTO NO CARTÓRIO!');
			END IF;

	   RETURN;

	  END TP_ATENDIMENTO;

END;
/
CREATE OR REPLACE TYPE BODY TP_SERVICODOATENDIMENTO AS

	MEMBER FUNCTION GETVALORTOTALATENDIMENTO RETURN NUMBER AS
	  V_TOTALATENDIMENTO NUMBER(8,2);
	BEGIN
		SELECT SUM(SA.VALORSERVICOREALIZADO) AS TOTAL INTO V_TOTALATENDIMENTO FROM TB_SERVICODOATENDIMENTO SA
		WHERE SA.REF_ATENDIMENTO.COD=DEREF(SELF.REF_ATENDIMENTO).COD;

		IF(V_TOTALATENDIMENTO IS NULL) THEN
		 V_TOTALATENDIMENTO:=0;
		END IF;

		RETURN V_TOTALATENDIMENTO;
	END GETVALORTOTALATENDIMENTO;

	MEMBER FUNCTION GETINFO RETURN VARCHAR2 AS
	 RETORNO VARCHAR2(32767);
	 INFOATENDIMENTO VARCHAR(32767);
	 INFOCLIENTE VARCHAR(32767);
	 INFOSERVICOATENDIDO VARCHAR(32767);
	 INFOFUNCRESPONSAVEL VARCHAR(32767);
	 INFODESCONTO VARCHAR(32767);
	 V_TOTATENDIMENTO NUMBER(8,2);
	 VALORSERVICO NUMBER(8,2);
	 V_DESCONTO NUMBER(8,2);
	 VALSERVREALIZADO NUMBER(8,2);
	BEGIN

	  SELECT
		 DEREF(SA.REF_RESPONSAVEL).GETINFORESUMIDA(),
		 DEREF(SA.REF_ATENDIMENTO).GETINFO(),
		 SA.GETVALORTOTALATENDIMENTO(),
		 DEREF(SA.REF_SERVICO).GETINFO(),
		 DEREF(SA.REF_SERVICO).VALOR
	   INTO INFOFUNCRESPONSAVEL, INFOATENDIMENTO, V_TOTATENDIMENTO, INFOSERVICOATENDIDO, VALORSERVICO
	  FROM TB_SERVICODOATENDIMENTO SA
		 WHERE SA.DATAHORAREALIZACAO=SELF.DATAHORAREALIZACAO;

	   RETORNO:=INFOATENDIMENTO||CHR(13)||
	   ' RESPONSÁVEL PELO SERVIÇO: '||INFOFUNCRESPONSAVEL||CHR(13)||
	   ' HORÁRIO DA PRESTAÇÃO DO SERVIÇO:'||TO_CHAR(SELF.DATAHORAREALIZACAO,'DD/MM/YYYY HH24:MI:SS')||CHR(13)||
	   ' SERVIÇO PRESTADO: '||INFOSERVICOATENDIDO||CHR(13)||
	   ' QUANTIDADE: '||SELF.QUANTIDADE||CHR(13);


	   IF(SELF.REF_DESCONTO IS NOT NULL) THEN
		 SELECT
		   DEREF(SA.REF_DESCONTO).GETINFO(),
		   DEREF(SA.REF_DESCONTO).VALOR INTO INFODESCONTO, V_DESCONTO
		 FROM TB_SERVICODOATENDIMENTO SA WHERE SA.DATAHORAREALIZACAO=SELF.DATAHORAREALIZACAO;
		 RETORNO:=RETORNO||' DESCONTO: '||INFODESCONTO||CHR(13);
		 VALSERVREALIZADO:=(VALORSERVICO*QUANTIDADE)-((VALORSERVICO*QUANTIDADE*V_DESCONTO)/100);
	   ELSE
		 VALSERVREALIZADO:=(VALORSERVICO*QUANTIDADE);
		 RETORNO:=RETORNO||' DESCONTO: <NENHUM>'||CHR(13);
	   END IF;

	   RETORNO:=RETORNO||' VALOR TOTAL DO SERVIÇO PRESTADO: R$ '||TO_CHAR(VALSERVREALIZADO)||CHR(13);

	   IF(SELF.OBSERVACAO IS NOT NULL) THEN
	   RETORNO:=RETORNO||' OBSERVAÇÕES: '||SELF.OBSERVACAO||CHR(13);
	   END IF;

	   RETURN RETORNO;
	END GETINFO;


	MEMBER FUNCTION GETRESPONSAVEL RETURN VARCHAR2 AS
	V_NOMERESPONSAVEL VARCHAR2(450);
	BEGIN
	  SELECT DEREF(SA.REF_RESPONSAVEL.REF_PESSOAFISICA).NOME AS RESPONSAVEL INTO V_NOMERESPONSAVEL FROM TB_SERVICODOATENDIMENTO SA
	  WHERE SA.DATAHORAREALIZACAO=SELF.DATAHORAREALIZACAO;
	  RETURN V_NOMERESPONSAVEL;
	END GETRESPONSAVEL;

	MEMBER FUNCTION GETCLIENTEATENDIDO RETURN VARCHAR2 AS
	V_NOMECLIENTE VARCHAR2(450);
	BEGIN
	  SELECT DEREF(SA.REF_ATENDIMENTO.REF_CLIENTE.REF_CLIENTE).NOME AS NOMECLIENTE
	  INTO V_NOMECLIENTE FROM TB_SERVICODOATENDIMENTO SA WHERE
	  SA.DATAHORAREALIZACAO=SELF.DATAHORAREALIZACAO;
	  RETURN V_NOMECLIENTE;
	END GETCLIENTEATENDIDO;

	 MEMBER FUNCTION GETDESCRICAOSERVICOATENDIDO RETURN VARCHAR2 AS
	V_DESCRICAOSERVICOATENDIDO VARCHAR2(450);
	BEGIN
	  SELECT DEREF(SA.REF_SERVICO).DESCRICAO AS V_DESCRICAOSERVICOATENDIDO INTO V_DESCRICAOSERVICOATENDIDO FROM TB_SERVICODOATENDIMENTO SA
	  WHERE SA.DATAHORAREALIZACAO=SELF.DATAHORAREALIZACAO;
	  RETURN V_DESCRICAOSERVICOATENDIDO;
	END GETDESCRICAOSERVICOATENDIDO;


	MAP MEMBER FUNCTION GETCODSERVICOATENDIDO RETURN NUMBER AS
	BEGIN
		RETURN SELF.CODITEM;
	END GETCODSERVICOATENDIDO;


	STATIC FUNCTION COMPARE(OBJ1 TP_SERVICODOATENDIMENTO, OBJ2 TP_SERVICODOATENDIMENTO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN
	  RETORNO:=FALSE;
	  IF(OBJ1.CODITEM=OBJ2.CODITEM) THEN
		RETORNO:=TRUE;
	  ELSE
		 RETORNO:=FALSE;
	  END IF;
	  RETURN RETORNO;
	END COMPARE;

	--CONSTRUTOR PARA CADASTRAR UM FUNCIONARIO SEM GRATIFICACOES E SEM SUPERVISOR
	CONSTRUCTOR FUNCTION TP_SERVICODOATENDIMENTO(V_CODATENDIMENTO IN NUMBER, V_DESCSERVICO IN VARCHAR2, V_CPFFUNCRESP IN VARCHAR2,V_OBS IN VARCHAR2,V_QTD IN INTEGER, V_DESCDESCONTO IN VARCHAR2) RETURN SELF AS RESULT AS
	REFATENDIMENTO REF TP_ATENDIMENTO;
	V_CLIENTEEBAIXARENDA VARCHAR2(450);
	REFSERVICO REF TP_SERVICO;
	V_VALORSERVICO NUMBER(8,6);
	REFRESPONSAVEL REF TP_FUNCIONARIO;
	REF_DESCONTO REF TP_DESCONTO;
	V_VALDESCONTO NUMBER(8,6);
	BEGIN

		SELECT REF(AC), DEREF(AC.REF_CLIENTE).EBAIXARENDA() INTO REFATENDIMENTO, V_CLIENTEEBAIXARENDA FROM TB_ATENDIMENTO AC WHERE AC.COD=V_CODATENDIMENTO;
		SELECT REF(SC), SC.VALOR INTO REFSERVICO, V_VALORSERVICO FROM TB_SERVICO SC WHERE SC.DESCRICAO=V_DESCSERVICO;
		SELECT REF(FR) INTO REFRESPONSAVEL FROM TB_FUNCIONARIO FR WHERE FR.REF_PESSOAFISICA.CPF=V_CPFFUNCRESP;


		SELF.CODITEM:=SEQ_SERVICODOATENDIMENTO.NEXTVAL;
		SELF.QUANTIDADE:=V_QTD;
		SELF.OBSERVACAO:=V_OBS;
		SELF.DATAHORAREALIZACAO:=SYSTIMESTAMP;

		IF(V_DESCDESCONTO IS NOT NULL) THEN
		   IF(V_CLIENTEEBAIXARENDA='É CLIENTE DE BAIXA RENDA.') THEN
			 SELECT REF(DS), DS.VALOR INTO REF_DESCONTO, V_VALDESCONTO FROM TB_DESCONTO DS WHERE DS.DESCRICAO=V_DESCDESCONTO;
			 SELF.REF_DESCONTO:=REF_DESCONTO;
			 SELF.VALORSERVICOREALIZADO:=(V_VALORSERVICO*V_QTD)-((V_VALORSERVICO*V_QTD*V_VALDESCONTO)/100);
		   ELSE
			  RAISE_APPLICATION_ERROR(-20015, 'CLIENTE INVÁLIDO! NÃO É POSSÍVEL OFERECER DESCONTO NO SERVIÇO POIS O CLIENTE NÃO É DE BAIXA RENDA!');
		   END IF;
		ELSE
		   SELF.VALORSERVICOREALIZADO:=(V_VALORSERVICO*V_QTD);
		END IF;


		 SELF.REF_ATENDIMENTO:=REFATENDIMENTO;
		 SELF.REF_SERVICO:=REFSERVICO;
		 SELF.REF_RESPONSAVEL:=REFRESPONSAVEL;

	  RETURN;
	END TP_SERVICODOATENDIMENTO;

  CONSTRUCTOR FUNCTION TP_SERVICODOATENDIMENTO(V_CODATENDIMENTO IN NUMBER, V_DESCSERVICO IN VARCHAR2, V_CPFFUNCRESP IN VARCHAR2,V_OBS IN VARCHAR2,V_QTD IN INTEGER, V_VALSERVATEND IN NUMBER,V_DESCDESCONTO IN VARCHAR2) RETURN SELF AS RESULT AS
	  REFATENDIMENTO REF TP_ATENDIMENTO;
	V_CLIENTEEBAIXARENDA VARCHAR2(450);
	REFSERVICO REF TP_SERVICO;
	V_VALORSERVICO NUMBER(8,6);
	REFRESPONSAVEL REF TP_FUNCIONARIO;
	REF_DESCONTO REF TP_DESCONTO;
	V_VALDESCONTO NUMBER(8,6);
	BEGIN
		 SELF.CODITEM:=SEQ_SERVICODOATENDIMENTO.NEXTVAL;
		SELECT REF(AC), DEREF(AC.REF_CLIENTE).EBAIXARENDA() INTO REFATENDIMENTO, V_CLIENTEEBAIXARENDA FROM TB_ATENDIMENTO AC WHERE AC.COD=V_CODATENDIMENTO;
		SELECT REF(SC), SC.VALOR INTO REFSERVICO, V_VALORSERVICO FROM TB_SERVICO SC WHERE SC.DESCRICAO=V_DESCSERVICO;
		SELECT REF(FR) INTO REFRESPONSAVEL FROM TB_FUNCIONARIO FR WHERE FR.REF_PESSOAFISICA.CPF=V_CPFFUNCRESP;

		SELF.QUANTIDADE:=V_QTD;
		SELF.OBSERVACAO:=V_OBS;
		SELF.DATAHORAREALIZACAO:=SYSTIMESTAMP;

		IF(V_DESCDESCONTO IS NOT NULL) THEN
		   IF(V_CLIENTEEBAIXARENDA='É CLIENTE DE BAIXA RENDA.') THEN
			 SELECT REF(DS), DS.VALOR INTO REF_DESCONTO, V_VALDESCONTO FROM TB_DESCONTO DS WHERE DS.DESCRICAO=V_DESCDESCONTO;
			 SELF.REF_DESCONTO:=REF_DESCONTO;
			 SELF.VALORSERVICOREALIZADO:=(V_VALORSERVICO*V_QTD)-((V_VALORSERVICO*V_QTD*V_VALDESCONTO)/100);
		   ELSE
			  RAISE_APPLICATION_ERROR(-20015, 'CLIENTE INVÁLIDO! NÃO É POSSÍVEL OFERECER DESCONTO NO SERVIÇO POIS O CLIENTE NÃO É DE BAIXA RENDA!');
		   END IF;
		ELSE
		   SELF.VALORSERVICOREALIZADO:=(V_VALORSERVICO*V_QTD);
		END IF;

		  SELF.REF_ATENDIMENTO:=REFATENDIMENTO;
		 SELF.REF_SERVICO:=REFSERVICO;
		 SELF.REF_RESPONSAVEL:=REFRESPONSAVEL;

	  RETURN;
	  END TP_SERVICODOATENDIMENTO;


	CONSTRUCTOR FUNCTION TP_SERVICODOATENDIMENTO(V_CODATENDIMENTO IN NUMBER, V_DESCSERVICO IN VARCHAR2, V_CPFFUNCRESP IN VARCHAR2,V_OBS IN VARCHAR2,V_QTD IN INTEGER, V_DESCDESCONTO IN VARCHAR2,V_DATAHORAREALIZACAO IN TIMESTAMP) RETURN SELF AS RESULT AS
	REFATENDIMENTO REF TP_ATENDIMENTO;
	V_CLIENTEEBAIXARENDA VARCHAR2(450);
	REFSERVICO REF TP_SERVICO;
	V_VALORSERVICO NUMBER;
	REFRESPONSAVEL REF TP_FUNCIONARIO;
	REF_DESCONTO REF TP_DESCONTO;
	V_VALDESCONTO NUMBER;
	BEGIN

		 SELF.CODITEM:=SEQ_SERVICODOATENDIMENTO.NEXTVAL;
		SELECT REF(AC), DEREF(AC.REF_CLIENTE).EBAIXARENDA() INTO REFATENDIMENTO, V_CLIENTEEBAIXARENDA FROM TB_ATENDIMENTO AC
		WHERE AC.COD=V_CODATENDIMENTO;
		SELECT REF(SC), SC.VALOR INTO REFSERVICO, V_VALORSERVICO FROM TB_SERVICO SC WHERE SC.DESCRICAO=V_DESCSERVICO;
		SELECT REF(FR) INTO REFRESPONSAVEL FROM TB_FUNCIONARIO FR WHERE FR.REF_PESSOAFISICA.CPF=V_CPFFUNCRESP;

		SELF.REF_ATENDIMENTO:=REFATENDIMENTO;
		SELF.REF_SERVICO:=REFSERVICO;
		SELF.REF_RESPONSAVEL:=REFRESPONSAVEL;


		SELF.QUANTIDADE:=V_QTD;
		SELF.OBSERVACAO:=V_OBS;

		SELF.DATAHORAREALIZACAO:=V_DATAHORAREALIZACAO;


		IF(V_DESCDESCONTO IS NOT NULL) THEN
		   IF(V_CLIENTEEBAIXARENDA='É CLIENTE DE BAIXA RENDA.') THEN
			 SELECT REF(DS), DS.VALOR INTO REF_DESCONTO, V_VALDESCONTO FROM TB_DESCONTO DS WHERE DS.DESCRICAO=V_DESCDESCONTO;
			 SELF.REF_DESCONTO:=REF_DESCONTO;
			 SELF.VALORSERVICOREALIZADO:=(V_VALORSERVICO*V_QTD)-((V_VALORSERVICO*V_QTD*V_VALDESCONTO)/100);
		   ELSE
			  RAISE_APPLICATION_ERROR(-20015, 'CLIENTE INVÁLIDO! NÃO É POSSÍVEL OFERECER DESCONTO NO SERVIÇO POIS O CLIENTE NÃO É DE BAIXA RENDA!');
		   END IF;
		ELSE
		   SELF.VALORSERVICOREALIZADO:=(V_VALORSERVICO*V_QTD);
		END IF;

	  RETURN;
	  END TP_SERVICODOATENDIMENTO;


   CONSTRUCTOR FUNCTION TP_SERVICODOATENDIMENTO(CODITEM IN NUMBER, REF_ATENDIMENTO IN REF TP_ATENDIMENTO, REF_SERVICO IN REF TP_SERVICO, REF_RESPONSAVEL IN REF TP_FUNCIONARIO, DATAHORAREALIZACAO IN TIMESTAMP, OBSERVACAO IN VARCHAR2, QUANTIDADE IN INTEGER, VALORSERVICOREALIZADO IN NUMBER, REF_DESCONTO IN REF TP_DESCONTO) RETURN SELF AS RESULT AS
	  REFATENDIMENTO REF TP_ATENDIMENTO;
	V_CLIENTEEBAIXARENDA VARCHAR2(450);
	REFSERVICO REF TP_SERVICO;
	V_VALORSERVICO NUMBER(8,6);
	REFRESPONSAVEL REF TP_FUNCIONARIO;
	V_VALDESCONTO NUMBER(8,6);
	BEGIN

		SELF.CODITEM:=SEQ_SERVICODOATENDIMENTO.NEXTVAL;
		SELF.REF_ATENDIMENTO:=REF_ATENDIMENTO;
		SELF.REF_SERVICO:=REF_SERVICO;
		SELF.REF_RESPONSAVEL:=REF_RESPONSAVEL;
		SELF.DATAHORAREALIZACAO:=DATAHORAREALIZACAO;
		SELF.OBSERVACAO:=OBSERVACAO;
		SELF.QUANTIDADE:=QUANTIDADE;

		IF(REF_DESCONTO IS NOT NULL) THEN
		   IF(V_CLIENTEEBAIXARENDA='É CLIENTE DE BAIXA RENDA.') THEN
			 SELECT  DS.VALOR INTO V_VALDESCONTO  FROM TB_DESCONTO DS WHERE DS.COD=DEREF(REF_DESCONTO).COD;
			 SELF.REF_DESCONTO:=REF_DESCONTO;
			 SELF.VALORSERVICOREALIZADO:=(V_VALORSERVICO*QUANTIDADE)-((V_VALORSERVICO*QUANTIDADE*V_VALDESCONTO)/100);
		   ELSE
			  RAISE_APPLICATION_ERROR(-20015, 'CLIENTE INVÁLIDO! NÃO É POSSÍVEL OFERECER DESCONTO NO SERVIÇO POIS O CLIENTE NÃO É DE BAIXA RENDA!');
		   END IF;
		ELSE
		   SELF.VALORSERVICOREALIZADO:=(V_VALORSERVICO*QUANTIDADE);
		END IF;

	  RETURN;
	  EXCEPTION
			WHEN OTHERS THEN
			IF(SELF.REF_ATENDIMENTO IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20016, 'ATENDIMENTO INVÁLIDO! ASSOCIE O SERVIÇO PRESTADO AO ATENDIMENTO CORRENTE DO CLIENTE QUE ESTÁ SENDO ATENDIDO!');
			ELSIF(SELF.REF_SERVICO IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20017, 'SERVIÇO INVÁLIDO! INFORME UM SERVIÇO CARTORIAL VÁLIDO NO ATENDIMENTO AO CLIENTE!');
			ELSIF(SELF.REF_RESPONSAVEL IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20018, 'FUNCIONÁRIO INVÁLIDO! INFORME UM FUNCIONÁRIO VÁLIDO PARA SE RESPONSABILIZAR NA PRESTAÇÃO DE SERVIÇO AO CLIENTE QUE ESTÁ SENDO ATENDIDO!');
			ELSIF((SELF.QUANTIDADE IS NULL)OR(SELF.QUANTIDADE<1)) THEN
				  RAISE_APPLICATION_ERROR(-20019, 'QUANTIDADE INVÁLIDA! INFORME UMA QUANTIDADE MAIOR OU IGUAL A UM PARA O SERVIÇO PRESTADO AO CLIENTE!');
			ELSIF(SELF.DATAHORAREALIZACAO IS NULL) THEN
				  RAISE_APPLICATION_ERROR(-20020, 'HORÁRIO DA PRESTAÇÃO DO SERVIÇO INVÁLIDO! INFORME UM HORÁRIO VÁLIDO!');
			END IF;
	  END TP_SERVICODOATENDIMENTO;

END;
/
CREATE OR REPLACE TYPE BODY TP_REGISTRO AS

	STATIC FUNCTION FAZREFERENCIAAALGUMREGISTRO(REFSERVICODOATENDIMENTO IN REF TP_SERVICODOATENDIMENTO) RETURN BOOLEAN AS --PARA GARANTIR RELACIONAMENTO 1P/1 USAR  NO CONTRUTOR DO OBJETO
		CODREGISTRO NUMBER;
		RETORNO BOOLEAN;
	BEGIN
		SELECT RA.NUMREGISTRO INTO CODREGISTRO FROM TB_REGISTRO RA WHERE
		RA.REF_SERVICODOATENDIMENTO.CODITEM=DEREF(REFSERVICODOATENDIMENTO).CODITEM;
		IF(CODREGISTRO IS NOT NULL) THEN
		  RETORNO:=TRUE;
		ELSE
		  RETORNO:=FALSE;
		END IF;
		RETURN RETORNO;
	END FAZREFERENCIAAALGUMREGISTRO;

	MEMBER PROCEDURE SETSERVICODOATENDIMENTO(REFSERVICODOATENDIMENTO IN REF TP_SERVICODOATENDIMENTO) AS
	BEGIN
		IF(TP_REGISTRO.FAZREFERENCIAAALGUMREGISTRO(REFSERVICODOATENDIMENTO)) THEN
		   RAISE_APPLICATION_ERROR(-20025, 'IMPOSSÍVEL ASSOCIAR O SERVIÇO AO REGISTRO! O SERVIÇO ATENDIDO NÃO PODERÁ SER ASSOCIADO
		   AO REGISTRO DO ARQUIVO POR QUE ELE JÁ SE ENCONTRA ASSOCIADO A OUTRO REGISTRO!');
		END IF;
		 SELF.REF_SERVICODOATENDIMENTO:=REFSERVICODOATENDIMENTO;
	END SETSERVICODOATENDIMENTO;


	MEMBER PROCEDURE SETLIVRO(REFLIVRO IN REF TP_LIVRO)  AS
	BEGIN
		SELF.REF_LIVRO:=REFLIVRO;
	END SETLIVRO;


	MEMBER FUNCTION GETSERVICODOATENDIMENTO RETURN VARCHAR2 AS
	RETORNO VARCHAR2(32767);
	 BEGIN

	  SELECT RA.REF_SERVICODOATENDIMENTO.GETINFO() INTO RETORNO FROM TB_REGISTRO RA
	  WHERE RA.REF_SERVICODOATENDIMENTO.CODITEM=DEREF(SELF.REF_SERVICODOATENDIMENTO).CODITEM;

	  RETURN RETORNO;
	 END GETSERVICODOATENDIMENTO;

	MEMBER FUNCTION GETLIVRO RETURN VARCHAR2 AS
		RETORNO VARCHAR2(32767);
	 BEGIN

	  SELECT RA.REF_LIVRO.GETINFO() INTO RETORNO FROM TB_REGISTRO RA
	  WHERE RA.REF_LIVRO.COD=DEREF(SELF.REF_LIVRO).COD AND RA.NUMREGISTRO=SELF.NUMREGISTRO;

	  RETURN RETORNO;
	END GETLIVRO;

	MEMBER FUNCTION GETINFO RETURN VARCHAR2 AS
	   RETORNO VARCHAR2(32767);
	 BEGIN

	  RETORNO:=SELF.GETLIVRO||CHR(13)||
	  ' NÚMERO DE REGISTRO: '||SELF.NUMREGISTRO||CHR(13)||
	  ' NÚMERO DA FOLHA: '||SELF.FOLHA||CHR(13);

	  RETORNO:=RETORNO||' '||SELF.GETSERVICODOATENDIMENTO;

	  RETURN RETORNO;
	END GETINFO;


	STATIC FUNCTION COMPARE(OBJ1 TP_REGISTRO, OBJ2 TP_REGISTRO) RETURN BOOLEAN AS
	RETORNO BOOLEAN;
	BEGIN
	 IF(OBJ1.NUMREGISTRO=OBJ2.NUMREGISTRO) THEN
	   RETORNO:=TRUE;
	 ELSE
	   RETORNO:=FALSE;
	 END IF;
	  RETURN RETORNO;
	END COMPARE;


	MAP MEMBER FUNCTION GETCODREGISTRO RETURN NUMBER AS
	BEGIN
	  RETURN SELF.NUMREGISTRO;
	END GETCODREGISTRO;


	CONSTRUCTOR FUNCTION TP_REGISTRO(V_FOLHA IN INTEGER, V_REFLIVRO IN REF TP_LIVRO, V_RESERVICOATENDIDO IN REF TP_SERVICODOATENDIMENTO) RETURN SELF AS RESULT AS
	BEGIN

	   SELF.NUMREGISTRO:=SEQ_REGISTRO.NEXTVAL;
	   SELF.FOLHA:=V_FOLHA;
	   SELF.REF_LIVRO:=V_REFLIVRO;
	   SELF.REF_SERVICODOATENDIMENTO:=V_RESERVICOATENDIDO;

		 RETURN;
	END TP_REGISTRO;

	CONSTRUCTOR FUNCTION TP_REGISTRO(NUMREGISTRO IN INTEGER, FOLHA IN INTEGER,  REF_LIVRO IN REF TP_LIVRO, REF_SERVICODOATENDIMENTO IN REF TP_SERVICODOATENDIMENTO) RETURN SELF AS RESULT AS
	BEGIN
	   SELF.NUMREGISTRO:=NUMREGISTRO;
	   SELF.FOLHA:=FOLHA;
	   SELF.REF_LIVRO:=REF_LIVRO;
	   SELF.REF_SERVICODOATENDIMENTO:=REF_SERVICODOATENDIMENTO;
		 RETURN;
	END TP_REGISTRO;

END;

/
---------------TRIGGERS DO SISTEMA DE CARTÓRIO -----------------------------------------------------------------------------------------------------------------------------------

--TRIGGER QUE IMPEDE QUE O MESMO CODIGO DE PESSOA FISICA APAREÇA NA TABELA PESSOA JURIDICA
--TRIGGER QUE IMPEDE QUE O MESMO CODIGO DE PESSOA JURIDICA APAREÇA NA TABELA PESSOA FISICA
--ESSAS DUAS TRIGGERS GARANTEM A HERANÇA DISJUNTA E TOTAL;

CREATE OR REPLACE TRIGGER TRG_HERANCA_DISJUNTATOTAL1
BEFORE INSERT OR UPDATE
ON TB_FISICA
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
NOVOCODPESSOAFISICA NUMBER;
CODPESSOAJURIDICA NUMBER;
QTDPJCADASTRADA NUMBER;
BEGIN

		NOVOCODPESSOAFISICA:=:NEW.COD;

		SELECT COUNT(OBJJ.COD) INTO QTDPJCADASTRADA FROM TB_JURIDICA OBJJ WHERE OBJJ.COD=NOVOCODPESSOAFISICA;

	   IF(QTDPJCADASTRADA>0) THEN

			SELECT OBJJ.COD INTO CODPESSOAJURIDICA FROM TB_JURIDICA OBJJ WHERE OBJJ.COD=NOVOCODPESSOAFISICA;

			IF(NOVOCODPESSOAFISICA=CODPESSOAJURIDICA) THEN
			   RAISE_APPLICATION_ERROR('-20090','IMPOSSÍVEL ADICIONAR/ATUALIZAR A PESSOA FÍSICA POIS JÁ EXISTE UMA PESSOA JURÍDICA COM O CÓDIGO INFORMADO.');
			END IF;

		END IF;

END TRG_HERANCA_DISJUNTATOTAL1;

/

CREATE OR REPLACE TRIGGER TRG_HERANCA_DISJUNTATOTAL2
BEFORE INSERT OR UPDATE
ON TB_JURIDICA
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
NOVOCODPESSOAJURIDICA NUMBER;
CODPESSOAFISICA NUMBER;
QTDPFCADASTRADA NUMBER;
BEGIN

	   NOVOCODPESSOAJURIDICA:=:NEW.COD;

	   SELECT COUNT(OBJF.COD)  INTO QTDPFCADASTRADA FROM TB_FISICA OBJF WHERE OBJF.COD=NOVOCODPESSOAJURIDICA;

	   IF(QTDPFCADASTRADA>0) THEN

		   SELECT OBJF.COD INTO CODPESSOAFISICA FROM TB_FISICA OBJF WHERE OBJF.COD=NOVOCODPESSOAJURIDICA;

			IF(NOVOCODPESSOAJURIDICA=CODPESSOAFISICA) THEN
				RAISE_APPLICATION_ERROR('-20091','IMPOSSÍVEL ADICIONAR/ATUALIZAR A PESSOA JURÍDICA POIS JÁ EXISTE UMA PESSOA FÍSICA COM O CÓDIGO INFORMADO.');
			END IF;

	   END IF;

END TRG_HERANCA_DISJUNTATOTAL2;

/

--TRIGGUER PARA NEGAR A INSERÇÃO OU ATUALIZACAO NA TABELA ATENDIMENTO CASO O FUNCIONARIO NAO SEJA UM FUNCIONARIO COM CARGO DE ATENDENTE

CREATE OR REPLACE TRIGGER TRG_ATENDIMENTO_ATENDENTE
BEFORE INSERT OR UPDATE
ON TB_ATENDIMENTO
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
FUNCIONARIO TP_FUNCIONARIO;
CARGOFUNCIONARIO TP_CARGO;
CODCARGOATENDENTE NUMBER;
BEGIN
		UTL_REF.SELECT_OBJECT(:NEW.REF_ATENDENTE, FUNCIONARIO);
		UTL_REF.SELECT_OBJECT(FUNCIONARIO.REF_CARGO, CARGOFUNCIONARIO);

		SELECT TC.COD
		  INTO CODCARGOATENDENTE
		FROM TB_CARGO TC WHERE TC.DESCRICAO='ATENDENTE';

		IF(CARGOFUNCIONARIO.COD<>CODCARGOATENDENTE) THEN
			  RAISE_APPLICATION_ERROR('-20095','IMPOSSÍVEL CADASTRAR/ALTERAR O ATENDIMENTO COM O FUNCIONÁRIO INFORMADO.
			  INFORME UM FUNCIONÁRIO VÁLIDO COM CARGO DE ATENDENTE PARA ATENDER AO CLIENTE.');
		END IF;

END TRG_ATENDIMENTO_ATENDENTE;

/

--TRIGGUER PARA QUANDO INSERIR DADOS NA TABELA ATENDIMENTO SALVAR OS DADOS DO ATENDIMENTO NA TABELA DE LOG ATENDIMENTO
--(PARA UMA POSSÍVEL AUDITORIA)
--(TRIGGER DE COPMPOUND  USANDO TABELA EM MEMORIA PARA REGISTRAR OS LOGS EM LOTES);

CREATE OR REPLACE TRIGGER TRG_LOG_ATENDIMENTO
FOR INSERT OR UPDATE OR DELETE
ON TB_ATENDIMENTO
COMPOUND TRIGGER

  TYPE T_LOGATENDIMENTO_CHANGES	   IS TABLE OF TB_LOGATENDIMENTO%ROWTYPE INDEX BY SIMPLE_INTEGER;
  V_LOGATENDIMENTO_CHANGES			T_LOGATENDIMENTO_CHANGES;

  V_INDEX				  SIMPLE_INTEGER	   := 0;
  V_THRESHHOLD	CONSTANT SIMPLE_INTEGER	   := 10; --MÁXIMO NÚMERO DE LINHAS DE ATENDIMENTO PARA ESCREVER DE UMA VEZ.
  --INDICANDO QUE A CADA 10 ATENDIMENTOS REALIZADOS OS DEZ SERÃO ENVIADOS PARA A TABELA DE AUDITORIA DE LOGS DO ATENDIMENTO

  V_USER		  VARCHAR2(50); --INDICA O USUARIO LOGADO NA SESSAO DO BANCO DE DADOS NO MOMENTO DA MANIPULAÇÃO DA TABELA DE ATENDIMENTO;

  OBJFUNCATENDENTE TP_FUNCIONARIO;
  OBJCLIENTE TP_CLIENTE;

  --PROCIDEMENTO UTIL PARA DESCARREGAR O LOG DA TABELA DE MEMORIA PARA A TABELA DE AUDITORIA TB_LOGATENDIMENTO
  PROCEDURE DESCARREGAR_LOGS
  IS
	V_UPDATES	   CONSTANT SIMPLE_INTEGER := V_LOGATENDIMENTO_CHANGES.COUNT();
  BEGIN

	FORALL V_COUNT IN 1..V_UPDATES
		INSERT INTO TB_LOGATENDIMENTO
			 VALUES V_LOGATENDIMENTO_CHANGES(V_COUNT);

	V_LOGATENDIMENTO_CHANGES.DELETE();
	V_INDEX := 0; --RESETANDO THRESHOLD PARA PRÓXIMA INSERÇÃO EM MASSA.

  END DESCARREGAR_LOGS;


  --DEPOIS DA INSERÇÃO REMOÇÃO OU ATUALIZAÇÃO NA TABELA DE ATENDIMENTO REGISTRE NA TABELA EM MEMORIA DE LOG DE ATENDIMENTO
  -- CASO ATINGA O LIMITE DE 10 ATENDIMENTOS NA TABELA DE LOG EM MEMORIA ENVIE OS LOGS PARA A TABELA DE AUDITORIA TB_LOGATENDIMENTO
  AFTER EACH ROW
  IS
  BEGIN

	IF INSERTING THEN
		V_INDEX := V_INDEX + 1;
		V_LOGATENDIMENTO_CHANGES(V_INDEX).CODLOG	   := SEQ_LOGATENDIMENTO.NEXTVAL;
		V_LOGATENDIMENTO_CHANGES(V_INDEX).DATAOPERACAO	   := SYSTIMESTAMP;
		V_LOGATENDIMENTO_CHANGES(V_INDEX).TIPOOPERACAO	   := 'INSERÇÃO'; --INSERÇÃO
		V_LOGATENDIMENTO_CHANGES(V_INDEX).USUARIO_BD	   := SYS_CONTEXT ('USERENV', 'SESSION_USER');

		UTL_REF.SELECT_OBJECT(:NEW.REF_ATENDENTE, OBJFUNCATENDENTE);
		UTL_REF.SELECT_OBJECT(:NEW.REF_CLIENTE, OBJCLIENTE);

		V_LOGATENDIMENTO_CHANGES(V_INDEX).TUPLA :=  NEW TP_TUPLAATENDIMENTO(:NEW.COD,OBJCLIENTE.COD,OBJFUNCATENDENTE.MATRICULA,
		:NEW.VALORTOTAL,:NEW.DATAATENDIMENTO);

	ELSIF UPDATING THEN

				V_INDEX := V_INDEX + 1;
				V_LOGATENDIMENTO_CHANGES(V_INDEX).CODLOG	   := SEQ_LOGATENDIMENTO.NEXTVAL;
				V_LOGATENDIMENTO_CHANGES(V_INDEX).DATAOPERACAO	   := SYSTIMESTAMP;
				V_LOGATENDIMENTO_CHANGES(V_INDEX).TIPOOPERACAO	   := 'ATUALIZAÇÃO'; --ATUALIZAÇÃO
				V_LOGATENDIMENTO_CHANGES(V_INDEX).USUARIO_BD	   := SYS_CONTEXT ('USERENV', 'SESSION_USER');

				UTL_REF.SELECT_OBJECT(:NEW.REF_ATENDENTE, OBJFUNCATENDENTE);
				UTL_REF.SELECT_OBJECT(:NEW.REF_CLIENTE, OBJCLIENTE);

				V_LOGATENDIMENTO_CHANGES(V_INDEX).TUPLA := NEW TP_TUPLAATENDIMENTO(:NEW.COD,OBJCLIENTE.COD,OBJFUNCATENDENTE.MATRICULA,
				:NEW.VALORTOTAL,:NEW.DATAATENDIMENTO);

	ELSIF DELETING THEN

				V_INDEX := V_INDEX + 1;
				V_LOGATENDIMENTO_CHANGES(V_INDEX).CODLOG	   := SEQ_LOGATENDIMENTO.NEXTVAL;
				V_LOGATENDIMENTO_CHANGES(V_INDEX).DATAOPERACAO	   := SYSTIMESTAMP;
				V_LOGATENDIMENTO_CHANGES(V_INDEX).TIPOOPERACAO	   := 'REMOÇÃO'; --REMOÇÃO
				V_LOGATENDIMENTO_CHANGES(V_INDEX).USUARIO_BD	   := SYS_CONTEXT('USERENV', 'SESSION_USER');

				UTL_REF.SELECT_OBJECT(:NEW.REF_ATENDENTE, OBJFUNCATENDENTE);
				UTL_REF.SELECT_OBJECT(:NEW.REF_CLIENTE, OBJCLIENTE);

				V_LOGATENDIMENTO_CHANGES(V_INDEX).TUPLA := NEW TP_TUPLAATENDIMENTO(:NEW.COD,OBJCLIENTE.COD,OBJFUNCATENDENTE.MATRICULA,
				:NEW.VALORTOTAL,:NEW.DATAATENDIMENTO);

	END IF;


	--SE O ÍNDICE ATINGIR O LIMITE DE 10 ATENDIMENTOS
	-- O LOG SERÁ DESCARREGADO

	IF V_INDEX >= V_THRESHHOLD THEN
	  DESCARREGAR_LOGS();
	END IF;

   END AFTER EACH ROW;

  -- DESCARREGAR LOG AO FIM DOS COMANDOS DML
  AFTER STATEMENT IS
  BEGIN
	 DESCARREGAR_LOGS();
  END AFTER STATEMENT;

END TRG_LOG_ATENDIMENTO;

/

--TRIGGERS PARA QUANDO INSERRIR DADOS NA TABELA SERVICODOATENDIMENTO QUE SEJA SALVO OS DADOS NA TABELA
--DE AUDITORIA DE LOG DO SERVICO DO ATENDIMENTO (SOLUÇÃO UTILIZADA FOI ATRAVÉS DE UMA MESCLA
--DE TRIGGER DE LINHA:TB_SERVICODOATENDIMENTO_TRG COM TRIGGER DE COMANDO:TB_SERVICODOATENDIMENTO_ST_TRG

CREATE OR REPLACE PACKAGE TRIGGER_API_LOGSERVATEND AS
	PROCEDURE TB_SERVATEND_ROW_CHANGE(TUPLA IN TP_TUPLASERVICODOATENDIMENTO, P_ACAO IN VARCHAR2);
	PROCEDURE TB_SERVATEND_STATMENT_CHANGE;
END TRIGGER_API_LOGSERVATEND;

/

CREATE OR REPLACE PACKAGE BODY TRIGGER_API_LOGSERVATEND AS

	TYPE T_CHANGE_REC IS RECORD(TUPLA TP_TUPLASERVICODOATENDIMENTO, ACAO TB_LOGSERVICODOATENDIMENTO.TIPOOPERACAO%TYPE);
	TYPE T_CHANGE_TAB IS TABLE OF T_CHANGE_REC;
	G_CHANGE_TAB T_CHANGE_TAB:=T_CHANGE_TAB();


	PROCEDURE TB_SERVATEND_ROW_CHANGE(TUPLA IN TP_TUPLASERVICODOATENDIMENTO, P_ACAO IN VARCHAR2) IS
	BEGIN

	   G_CHANGE_TAB.EXTEND;
	   G_CHANGE_TAB(G_CHANGE_TAB.LAST).TUPLA:=TUPLA;
	   G_CHANGE_TAB(G_CHANGE_TAB.LAST).ACAO:=P_ACAO;

	END TB_SERVATEND_ROW_CHANGE;


	PROCEDURE TB_SERVATEND_STATMENT_CHANGE IS
	BEGIN

	  --PERCORRER OS DADOS DA TABELA EM MEMÓRIA E ENVIAR PARA A TABELA DE LOG
	  FOR I IN G_CHANGE_TAB.FIRST .. G_CHANGE_TAB.LAST LOOP

	   INSERT INTO TB_LOGSERVICODOATENDIMENTO VALUES(SEQ_LOGSERVICODOATENDIMENTO.NEXTVAL,SYSTIMESTAMP,G_CHANGE_TAB(I).ACAO,
	   SYS_CONTEXT ('USERENV', 'SESSION_USER'),G_CHANGE_TAB(I).TUPLA);

	  END LOOP;

	  G_CHANGE_TAB.DELETE;

	END TB_SERVATEND_STATMENT_CHANGE;

END TRIGGER_API_LOGSERVATEND;

/
CREATE OR REPLACE TRIGGER TB_SERVICODOATENDIMENTO_TRG
AFTER INSERT OR UPDATE OR DELETE ON TB_SERVICODOATENDIMENTO
FOR EACH ROW
DECLARE
  OBJATENDIMENTO TP_ATENDIMENTO;
  OBJFUNCRESPONSAVEL TP_FUNCIONARIO;
  OBJSERVICO TP_SERVICO;
  OBJDESCONTO TP_DESCONTO;
  CODDESCONTO NUMBER;
  V_TUPLA TP_TUPLASERVICODOATENDIMENTO;
BEGIN

  UTL_REF.SELECT_OBJECT(:NEW.REF_ATENDIMENTO, OBJATENDIMENTO);
  UTL_REF.SELECT_OBJECT(:NEW.REF_SERVICO, OBJSERVICO);
  UTL_REF.SELECT_OBJECT(:NEW.REF_RESPONSAVEL, OBJFUNCRESPONSAVEL);

  IF(:NEW.REF_DESCONTO IS NOT NULL) THEN
	  UTL_REF.SELECT_OBJECT(:NEW.REF_DESCONTO, OBJDESCONTO);
	  CODDESCONTO:=OBJDESCONTO.COD;
  ELSE
	  CODDESCONTO:=NULL;
  END IF;

  V_TUPLA := NEW TP_TUPLASERVICODOATENDIMENTO(:NEW.CODITEM,OBJATENDIMENTO.COD,CODDESCONTO,OBJFUNCRESPONSAVEL.MATRICULA,:NEW.DATAHORAREALIZACAO, OBJSERVICO.COD, :NEW.OBSERVACAO, :NEW.VALORSERVICOREALIZADO, :NEW.QUANTIDADE);

  IF(INSERTING) THEN
   --INSERÇÃO
   TRIGGER_API_LOGSERVATEND.TB_SERVATEND_ROW_CHANGE(TUPLA =>V_TUPLA, P_ACAO=>'INSERÇÃO');
  ELSIF(UPDATING) THEN
   --ATUALIZAÇÃO
   TRIGGER_API_LOGSERVATEND.TB_SERVATEND_ROW_CHANGE(TUPLA =>V_TUPLA, P_ACAO=>'ATUALIZAÇÃO');
  ELSE
   --DELEÇÃO
   TRIGGER_API_LOGSERVATEND.TB_SERVATEND_ROW_CHANGE(TUPLA =>V_TUPLA, P_ACAO=>'REMOÇÃO');
  END IF;

END TB_SERVICODOATENDIMENTO_TRG;
/

CREATE OR REPLACE TRIGGER TB_SERVICODOATENDIMENTO_ST_TRG
AFTER INSERT OR UPDATE OR DELETE ON TB_SERVICODOATENDIMENTO
BEGIN
  TRIGGER_API_LOGSERVATEND.TB_SERVATEND_STATMENT_CHANGE;
END TB_SERVICODOATENDIMENTO_ST_TRG;



/

--TRIGGUER PARA QUANDO INSERIR, ATUALIZAR, OU DELETAR DADOS NA TABELA REGISTRO QUE SEJA SALVO OS DADOS DA OPERAÇÃO REALIZADA
--NA TABELA DE AUDITORIA DE LOG DO REGISTRO (TRIGGER DE COPMPOUND USANDO TABELA EM MEMORIA PARA REGISTRAR OS LOGS EM LOTES)

CREATE OR REPLACE TRIGGER TRG_LOG_REGISTRO
FOR INSERT OR UPDATE OR DELETE
ON TB_REGISTRO
COMPOUND TRIGGER

  TYPE T_LOGREGISTRO_CHANGES	   IS TABLE OF TB_LOGREGISTRO%ROWTYPE INDEX BY SIMPLE_INTEGER;
  V_LOGREGISTRO_CHANGES			T_LOGREGISTRO_CHANGES;

  V_INDEX				  SIMPLE_INTEGER	   := 0;
  V_THRESHHOLD	CONSTANT SIMPLE_INTEGER	   := 10; --MÁXIMO NÚMERO DE LINHAS DE REGISTROS EM ARQUIVO PARA ESCREVER DE UMA VEZ.
  --INDICANDO QUE A CADA 10 REGISTROS DE ARQUIVO REALIZADOS OS DEZ SERÃO ENVIADOS PARA A TABELA DE AUDITORIA DE LOGS DE REGISTROS
  --NO ARQUIVO DO CARTÓRIO

  V_USER		  VARCHAR2(50); --INDICA O USUARIO LOGADO NA SESSAO DO BANCO DE DADOS NO MOMENTO DA MANIPULAÇÃO DA TABELA DE REGISTRO;

  OBJLIVRO TP_LIVRO;
  OBJSERVICOREGISTRADO TP_SERVICODOATENDIMENTO;
  CODLIVRO NUMBER;
  CODSERVICOREGISTRADO NUMBER;

  --PROCIDEMENTO UTIL PARA DESCARREGAR O LOG DA TABELA DE MEMORIA PARA A TABELA DE AUDITORIA TB_LOGREGISTRO
  PROCEDURE DESCARREGAR_LOGS
  IS
	V_UPDATES	   CONSTANT SIMPLE_INTEGER := V_LOGREGISTRO_CHANGES.COUNT();
  BEGIN

	FORALL V_COUNT IN 1..V_UPDATES
		INSERT INTO TB_LOGREGISTRO
			 VALUES V_LOGREGISTRO_CHANGES(V_COUNT);

	V_LOGREGISTRO_CHANGES.DELETE();
	V_INDEX := 0; --RESETANDO THRESHOLD PARA PRÓXIMA INSERÇÃO EM MASSA.

  END DESCARREGAR_LOGS;

  --DEPOIS DA INSERÇÃO, REMOÇÃO OU ATUALIZAÇÃO NA TABELA DE REGISTRO REGISTRE A OPERAÇÃO NA TABELA EM MEMORIA DE LOG
  --DE REGISTRO QUE CASO ATINGA O LIMITE DE 10 REGISTROS NA TABELA DE LOG EM MEMORIA
  --OS LOGS SÃO ENVIADOS PARA A TABELA DE AUDITORIA TB_LOGREGISTRO
  AFTER EACH ROW
  IS
  BEGIN

	IF INSERTING THEN

		V_INDEX := V_INDEX + 1;
		V_LOGREGISTRO_CHANGES(V_INDEX).CODLOG	   := SEQ_LOGREGISTRO.NEXTVAL;
		V_LOGREGISTRO_CHANGES(V_INDEX).DATAOPERACAO	   := SYSTIMESTAMP;
		V_LOGREGISTRO_CHANGES(V_INDEX).TIPOOPERACAO	   := 'INSERÇÃO'; --INSERÇÃO
		V_LOGREGISTRO_CHANGES(V_INDEX).USUARIO_BD	   := SYS_CONTEXT ('USERENV', 'SESSION_USER');

		UTL_REF.SELECT_OBJECT(:NEW.REF_LIVRO, OBJLIVRO);
		UTL_REF.SELECT_OBJECT(:NEW.REF_SERVICODOATENDIMENTO, OBJSERVICOREGISTRADO);

		V_LOGREGISTRO_CHANGES(V_INDEX).TUPLA :=
		NEW TP_TUPLAREGISTRO(:NEW.NUMREGISTRO,:NEW.FOLHA,OBJLIVRO.COD,OBJSERVICOREGISTRADO.CODITEM);

	ELSIF UPDATING THEN

		V_INDEX := V_INDEX + 1;
		V_LOGREGISTRO_CHANGES(V_INDEX).CODLOG	   := SEQ_LOGREGISTRO.NEXTVAL;
		V_LOGREGISTRO_CHANGES(V_INDEX).DATAOPERACAO	   := SYSTIMESTAMP;
		V_LOGREGISTRO_CHANGES(V_INDEX).TIPOOPERACAO	   := 'ATUALIZAÇÃO'; --ATUALIZAÇÃO
		V_LOGREGISTRO_CHANGES(V_INDEX).USUARIO_BD	   := SYS_CONTEXT ('USERENV', 'SESSION_USER');

		UTL_REF.SELECT_OBJECT(:NEW.REF_LIVRO, OBJLIVRO);
		UTL_REF.SELECT_OBJECT(:NEW.REF_SERVICODOATENDIMENTO, OBJSERVICOREGISTRADO);

		V_LOGREGISTRO_CHANGES(V_INDEX).TUPLA :=
		NEW TP_TUPLAREGISTRO(:NEW.NUMREGISTRO,:NEW.FOLHA,OBJLIVRO.COD,OBJSERVICOREGISTRADO.CODITEM);


	ELSIF DELETING THEN

		V_INDEX := V_INDEX + 1;
		V_LOGREGISTRO_CHANGES(V_INDEX).CODLOG	   := SEQ_LOGREGISTRO.NEXTVAL;
		V_LOGREGISTRO_CHANGES(V_INDEX).DATAOPERACAO	   := SYSTIMESTAMP;
		V_LOGREGISTRO_CHANGES(V_INDEX).TIPOOPERACAO	   := 'REMOÇÃO'; --REMOÇÃO
		V_LOGREGISTRO_CHANGES(V_INDEX).USUARIO_BD	   := SYS_CONTEXT ('USERENV', 'SESSION_USER');

		UTL_REF.SELECT_OBJECT(:NEW.REF_LIVRO, OBJLIVRO);
		UTL_REF.SELECT_OBJECT(:NEW.REF_SERVICODOATENDIMENTO, OBJSERVICOREGISTRADO);

		V_LOGREGISTRO_CHANGES(V_INDEX).TUPLA :=
		NEW TP_TUPLAREGISTRO(:NEW.NUMREGISTRO,:NEW.FOLHA,OBJLIVRO.COD,OBJSERVICOREGISTRADO.CODITEM);

	END IF;

	--SE O ÍNDICE ATINGIR O LIMITE DE 10 REGISTROS
	-- O LOG SERÁ DESCARREGADO NA TABELA DE AUDITORIA TB_LOGREGISTRO
	IF V_INDEX >= V_THRESHHOLD THEN
	  DESCARREGAR_LOGS();
	END IF;

   END AFTER EACH ROW;

  -- DESCARREGAR LOG AO FIM DOS COMANDOS DML
  AFTER STATEMENT IS
  BEGIN
	 DESCARREGAR_LOGS();
  END AFTER STATEMENT;

END TRG_LOG_REGISTRO;

/

--  TRIGGERS PARA IMPEDIR A EXCLUSÃO DE PESSOA FISICA OU JURIDICA CASO ELA ESTEJA ASSOCIADA A ALGUM CLIENTE
--AS TRIGGERS: TRG_REFERENCIA_CLIENTEPJ E TRG_REFERENCIA_CLIENTEPF GARANTEM ISSO.

CREATE OR REPLACE TRIGGER TRG_REFERENCIA_CLIENTEPJ
BEFORE DELETE
ON TB_JURIDICA
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
CODPESSOAJURIDICA NUMBER;
CODOBJPESSOACLIENTE NUMBER;
QTDCLIREFPESSOA NUMBER;
BEGIN


		CODPESSOAJURIDICA:=:OLD.COD;

		SELECT COUNT(OBJC.REF_CLIENTE.COD) INTO QTDCLIREFPESSOA FROM TB_CLIENTE OBJC WHERE OBJC.REF_CLIENTE.COD=CODPESSOAJURIDICA;

		IF(QTDCLIREFPESSOA>0) THEN
			   RAISE_APPLICATION_ERROR('-20094','IMPOSSÍVEL EXCLUIR PESSOA JURÍDICA POR QUE ELA JA ENCONTRA-SE ASSOCIADA A UM CÓDIGO DE CLIENTE.');
		END IF;

COMMIT;
END TRG_REFERENCIA_CLIENTEPJ;

/

CREATE OR REPLACE TRIGGER TRG_REFERENCIA_CLIENTEPF
BEFORE DELETE
ON TB_FISICA
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
CODPESSOAFISICA NUMBER;
CODOBJPESSOACLIENTE NUMBER;
QTDCLIREFPESSOA NUMBER;
BEGIN


		CODPESSOAFISICA:=:OLD.COD;

		--SELECT COUNT(OBJC.REF_CLIENTE.COD)  FROM TB_CLIENTE OBJC WHERE OBJC.REF_CLIENTE.COD=14;

		SELECT COUNT(OBJC.REF_CLIENTE.COD) INTO QTDCLIREFPESSOA FROM TB_CLIENTE OBJC WHERE OBJC.REF_CLIENTE.COD=CODPESSOAFISICA;
		IF(QTDCLIREFPESSOA>0) THEN
			  RAISE_APPLICATION_ERROR('-20093','IMPOSSÍVEL EXCLUIR PESSOA FÍSICA POR QUE ELA JÁ ENCONTRA-SE ASSOCIADA A UM CÓDIGO DE CLIENTE.');
		END IF;
COMMIT;
END TRG_REFERENCIA_CLIENTEPF;

/

--TRIGGER DO SISTEMA DE CARTÓRIO QUE IMPEDE A EXCLUSÃO DE UM FUNCIONARIO QUE SEJA SUPERVISOR  DO OUTROS FUNCIONARIOS ------

CREATE OR REPLACE TRIGGER TRG_BLOCK_DELFUNCSUPERVISOR
BEFORE DELETE
ON TB_FUNCIONARIO
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;
ESUPERVISOR BOOLEAN;
BEGIN
		ESUPERVISOR:=FALSE;

		FOR V_REG IN (SELECT F.MATRICULA AS MATRICULA FROM TB_FUNCIONARIO F WHERE  F.MATRICULA=:OLD.MATRICULA AND F.MATRICULA IN (SELECT  F2.REF_SUPERVISOR.MATRICULA AS MAT_SUPERVISORES FROM TB_FUNCIONARIO F2 WHERE F2.REF_SUPERVISOR IS NOT DANGLING))
		LOOP
			IF(:OLD.MATRICULA=V_REG.MATRICULA) THEN
				ESUPERVISOR:=TRUE;
			END IF;
		END LOOP;

  IF(ESUPERVISOR=TRUE) THEN
	RAISE_APPLICATION_ERROR('-20051','IMPOSSÍVEL EXCLUIR O FUNCIONÁRIO POIS O MESMO É SUPERVISOR DE OUTROS FUNCIONÁRIOS.');
  END IF;

COMMIT;
END TRG_BLOCK_DELFUNCSUPERVISOR;

/

----TRIGGER PARA QUANDO FOR INSERIDO OU ATUALIZADO UM ITEM DO SERVICO DE ATENDIMENTO QUE SEJA CALCULADO ANTES O NOVO VALOR DO ITEM QUE ESTA
----SENDO INSERIDO OU ATUALIZADO E ATUALIZE O SEU VALOR. ALÉM DISSO DEVERA SER ATUALIZADO O VALOR TOTAL DO ATENDIMENTO SOMANDO-SE OS OUTROS
----SERVICOS ATENDIDOS JUNTAMENTE COM ESTE NOVO SERVICO QUE SERÁ ATUALIZADO OU INSERIDO NO ATENDIMENTO REALIZADO;

CREATE OR REPLACE TRIGGER TRG_SERVDOATENDIMENTO
BEFORE INSERT OR UPDATE
ON TB_SERVICODOATENDIMENTO
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;

OBJATENDIMENTO TP_ATENDIMENTO;
OBJSERVICODOATENDIMENTO TP_SERVICODOATENDIMENTO;
OBJSERVICO TP_SERVICO;
OBJDESCONTO TP_DESCONTO;
TOTALATENDIMENTOANTES NUMBER;
TOTSERVICODOATENDIMENTO NUMBER;
NOVOTOTAL NUMBER;

BEGIN

   --//PEGA O OBJETO ATENDIMENTO;
   UTL_REF.SELECT_OBJECT(:NEW.REF_ATENDIMENTO, OBJATENDIMENTO);

   --PEGA O VALOR TOTAL DE ATENDIMENTO SOMANDO TODOS OS ITENS MENOS O QUE ESTA SENDO MODIFICADO ANTES DA OPERAÇÃO
   SELECT SUM(SA.VALORSERVICOREALIZADO) AS TOTAL INTO TOTALATENDIMENTOANTES  FROM TB_SERVICODOATENDIMENTO SA
		WHERE SA.REF_ATENDIMENTO.COD=OBJATENDIMENTO.COD AND SA.CODITEM<>:NEW.CODITEM;

  IF(TOTALATENDIMENTOANTES IS NOT NULL) THEN

	   --TEM QUE PEGAR O SERVIÇODOATENDIMENTO QUE ESTA SENDO INSERIDO OU ATUALIZADO
	   UTL_REF.SELECT_OBJECT(:NEW.REF_SERVICO, OBJSERVICO);

	   --E CALCULAR O VALOR DO NOVO SERVIÇO A SER INSERIDO/ATUALIZADO DEPOIS SOMA AO VALOR QUE ESTA EM ATENDIMENTO
	   IF(:NEW.REF_DESCONTO IS NOT NULL) THEN
		 UTL_REF.SELECT_OBJECT(:NEW.REF_DESCONTO, OBJDESCONTO);
		 TOTSERVICODOATENDIMENTO:=((:NEW.QUANTIDADE*OBJSERVICO.VALOR)-((:NEW.QUANTIDADE*OBJSERVICO.VALOR*OBJDESCONTO.VALOR)/100));
	   ELSE
		TOTSERVICODOATENDIMENTO:=:NEW.QUANTIDADE*OBJSERVICO.VALOR;
	   END IF;

	   --ATUALIZA O VALORDOSERVICOREALIZADO
		:NEW.VALORSERVICOREALIZADO:=TOTSERVICODOATENDIMENTO;

		--INSERE O NOVO TOTAL DO ATENDIMENTO QUE É A SOMA DO NOVO SERVICO ATUALIZADO OU INSERIDO MAIS O TOTAL QUE DOS OUTROS SERVICOS DO ATENDIMENTO;
		NOVOTOTAL:=TOTALATENDIMENTOANTES+TOTSERVICODOATENDIMENTO;


	   UPDATE TB_ATENDIMENTO TA SET TA.VALORTOTAL=NOVOTOTAL
	   WHERE TA.COD=OBJATENDIMENTO.COD;


  END IF;

COMMIT;
END TRG_SERVDOATENDIMENTO;

/

--TRIGGUER PARA GARANTIR QUE EXISTA APENAS UMA REFERENCIA ENTRE A TABELA FUNCIONARIO E A TABELA PESSOA FISICA PARA UM DETERMINADO
-- CLIENTE DE UM DADOS CPF TANTO NA INSERÇAO QUANTO NA ATUALIZAÇÃO DA TABELA DE FUNCIONÁRIO;

CREATE OR REPLACE TRIGGER TRG_GRANT_UM_P_UM_FUNC_PFISICA
BEFORE INSERT OR UPDATE
ON TB_FUNCIONARIO
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;

QTDREFERENCIAPF NUMBER;
OBJPESSOAFISICA TP_FISICA;
OBJPESSOAFISICANOVO TP_FISICA;
OBJPESSOAFISICAANTIGO TP_FISICA;
BEGIN

   IF(INSERTING) THEN

		  UTL_REF.SELECT_OBJECT(:NEW.REF_PESSOAFISICA, OBJPESSOAFISICA);

		  --AO INSERIR UM FUNCIONARIO VERIFICAR SE JÁ EXISTE FUNCIONARIO QUE REFERENCIA A PESSOA FISICA INFORMADA
		  --SE JÁ EXISTIR CANCELAR A INSERÇÃO
		  SELECT COUNT(PF.REF_PESSOAFISICA.COD) INTO QTDREFERENCIAPF FROM TB_FUNCIONARIO PF WHERE
		  PF.REF_PESSOAFISICA.COD=OBJPESSOAFISICA.COD;

		  IF(QTDREFERENCIAPF>0) THEN
			 RAISE_APPLICATION_ERROR('-20099','IMPOSSÍVEL CADASTRAR FUNCIONARIO
			 POIS JÁ EXISTE UM FUNCIONÁRIO RELACIONADO A PESSOA FISICA INFORMADA!');
		  END IF;
   END IF;

   IF(UPDATING) THEN

		   UTL_REF.SELECT_OBJECT(:NEW.REF_PESSOAFISICA, OBJPESSOAFISICANOVO);
		   UTL_REF.SELECT_OBJECT(:OLD.REF_PESSOAFISICA, OBJPESSOAFISICAANTIGO);

		  --AO ATUALIZAR UM FUNCIONARIO VERIFICAR SE A NOVA REFERÊNCIA A PESSOA FÍSICA REFERÊNCIA A MESMA PESSOA FISICA(OLD)
		  --SE SIM DEIXAR A ATUALIZAÇÃO ACONTECER SENÃO
		  --VERIFICAR SE A NOVA REFERÊNCIA JA EXISTE PARA UM OUTRO FUNCIONÁRIO SE JA EXISTIR CANCELAR A OPERAÇÃO DE ATUALIZAÇÃO
		  --SENÃO PROSSEGUIR COM A MESMA

		  IF(OBJPESSOAFISICANOVO.COD<>OBJPESSOAFISICAANTIGO.COD) THEN

				   SELECT COUNT(FC.REF_PESSOAFISICA.COD) INTO QTDREFERENCIAPF FROM TB_FUNCIONARIO FC
				   WHERE FC.REF_PESSOAFISICA.COD=OBJPESSOAFISICANOVO.COD;

				   IF(QTDREFERENCIAPF>0) THEN

					   RAISE_APPLICATION_ERROR('-20098','IMPOSSÍVEL ALTERAR FUNCIONÁRIO
							POIS JÁ EXISTE UM FUNCIONÁRIO RELACIONADO A PESSOA FISICA INFORMADA!');
				   END IF;
		  END IF;

   END IF;


COMMIT;
END TRG_GRANT_UM_P_UM_FUNC_PFISICA;

/

--TRIGGER PARA GARANTIR QUE EXISTA APENAS UMA REFERENCIA ENTRE A TABELA REGISTRO E A TABELA SERVICO DO ATENDIMENTO;
-- TANTO NA INSERÇAO QUANTO NA ATUALIZAÇÃO DA TABELA REGISTRO INDICANDO QUE UM DETERMINADO REGISTRO SÓ PODE ESTAR ASSOCIADO A UM DETERMINADO
--SERVIÇO ATENDIDO E QUE UM SERVIÇO ATENDIDO SÓ PODE ESTAR ASSOCIADO A UM DETERMINADO REGISTRO

CREATE OR REPLACE TRIGGER TRG_GRANT_UM_P_UM_REG_SERVA
BEFORE INSERT OR UPDATE
ON TB_REGISTRO
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;

QTDREFERENCIASA NUMBER;
OBJSERVICODOATENDIMENTO TP_SERVICODOATENDIMENTO;
OBJSERVICODOATENDIMENTONOVO TP_SERVICODOATENDIMENTO;
OBJSERVICODOATENDIMENTOANTIGO TP_SERVICODOATENDIMENTO;
BEGIN

   IF(INSERTING) THEN

		  UTL_REF.SELECT_OBJECT(:NEW.REF_SERVICODOATENDIMENTO, OBJSERVICODOATENDIMENTO);

		  --AO INSERIR UM REGISTRO NO ARQUIVO VERIFICAR SE JÁ EXISTE SERVICODOATENDIMENTO QUE REFERENCIA O REGISTRO INFORMADO
		  --SE JÁ EXISTIR CANCELAR A INSERÇÃO
		  SELECT COUNT(RA.REF_SERVICODOATENDIMENTO.CODITEM) INTO QTDREFERENCIASA FROM TB_REGISTRO RA WHERE
		  RA.REF_SERVICODOATENDIMENTO.CODITEM=OBJSERVICODOATENDIMENTO.CODITEM;

		  IF(QTDREFERENCIASA>0) THEN

			 RAISE_APPLICATION_ERROR('-20003','IMPOSSÍVEL CADASTRAR REGISTRO NO ARQUIVO
			 POIS JÁ EXISTE REGISTRO RELACIONADO AO SERVIÇO DO ATENDIMENTO INFORMADO!');
		  END IF;
   END IF;

   IF(UPDATING) THEN

		   UTL_REF.SELECT_OBJECT(:NEW.REF_SERVICODOATENDIMENTO, OBJSERVICODOATENDIMENTONOVO);
		   UTL_REF.SELECT_OBJECT(:OLD.REF_SERVICODOATENDIMENTO, OBJSERVICODOATENDIMENTOANTIGO);

		  --AO ATUALIZAR UM REGISTRO DE ARQUIVO VERIFICAR SE A NOVA REFERÊNCIA A SERVIÇO DO ATENDIMENTO REFERÊNCIA
		  --O MESMO SERVIÇO DO ATENDIMENTO ANTIGO(OLD)
		  --SE SIM DEIXAR A ATUALIZAÇÃO ACONTECER SENÃO
		  --VERIFICAR SE A NOVA REFERÊNCIA JA EXISTE PARA UM OUTRO REGISTRO NO ARQUIVO SE JA EXISTIR CANCELAR A OPERAÇÃO DE ATUALIZAÇÃO
		  --SENÃO PROSSEGUIR COM A MESMA

		  IF(OBJSERVICODOATENDIMENTONOVO.CODITEM<>OBJSERVICODOATENDIMENTOANTIGO.CODITEM) THEN

				   SELECT COUNT(RA.REF_SERVICODOATENDIMENTO.CODITEM) INTO QTDREFERENCIASA FROM TB_REGISTRO RA
				   WHERE RA.REF_SERVICODOATENDIMENTO.CODITEM=OBJSERVICODOATENDIMENTONOVO.CODITEM;

				   IF(QTDREFERENCIASA>0) THEN
					   RAISE_APPLICATION_ERROR('-20099','IMPOSSÍVEL ALTERAR REGISTRO
							POIS JÁ EXISTE OUTRO REGISTRO RELACIONADO AO SERVIÇO DO ATENDIMENTO INFORMADO!');
				   END IF;
		  END IF;

   END IF;


COMMIT;
END TRG_GRANT_UM_P_UM_REG_SERVA;

/


--TRIGGUER PARA GARANTIR QUE EXISTA APENAS UMA REFERÊNCIA ENTRE A TABELA CLIENTE E A TABELA PESSOA FISICA
--TANTO NA INSERÇAO QUANTO NA ATUALIZAÇÃO DA TABELA CLIENTE INDICANDO QUE UMA PESSOA FISICA SÓ PODE REFERENCIAR UM DETERMINADO CLIENTE;

CREATE OR REPLACE TRIGGER TRG_GRANT_UM_P_UM_CLI_PESFIS
BEFORE INSERT OR UPDATE
ON TB_CLIENTE
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;

QTDREFERENCIAPF NUMBER;
OBJPESSOAFISICA TP_PESSOA;
OBJPESSOAFISICANOVO TP_PESSOA;
OBJPESSOAFISICAANTIGO TP_PESSOA;

BEGIN

   IF(INSERTING) THEN

		  UTL_REF.SELECT_OBJECT(:NEW.REF_CLIENTE, OBJPESSOAFISICA);

		  --AO INSERIR UM CLIENTE NO CARTORIO VERIFICAR SE JÁ EXISTE PESSOA FISICA QUE REFERENCIA O CLIENTE INFORMADO
		  --SE JÁ EXISTIR CANCELAR A INSERÇÃO

		  --VAI BUSCAR NAS DUAS TABELAS REF_CLIENTE SE REFERE TANTO A PESSOA JURIDICA COMO FISICA AUMENTA O PODER DE CONSULTA OBJETO RELACIONAL É O BICHO
		  --SELECT COUNT(TC.REF_CLIENTE.COD)  FROM TB_CLIENTE TC

		  SELECT COUNT(TC.REF_CLIENTE.COD) INTO QTDREFERENCIAPF FROM TB_CLIENTE TC WHERE
		  TC.REF_CLIENTE.COD=OBJPESSOAFISICA.COD;


		IF(QTDREFERENCIAPF IS NOT NULL) THEN
		  IF(QTDREFERENCIAPF>0) THEN
			 RAISE_APPLICATION_ERROR('-20004','IMPOSSÍVEL CADASTRAR CLIENTE
			 POIS JÁ EXISTE CLIENTE RELACIONADO A PESSOA FISICA INFORMADA!');
		  END IF;
	   END IF;
   END IF;

   IF(UPDATING) THEN

		   UTL_REF.SELECT_OBJECT(:NEW.REF_CLIENTE, OBJPESSOAFISICANOVO);
		   UTL_REF.SELECT_OBJECT(:OLD.REF_CLIENTE, OBJPESSOAFISICAANTIGO);

		  --AO ATUALIZAR UM REGISTRO DE ARQUIVO VERIFICAR SE A NOVA REFERÊNCIA A SERVIÇO DO ATENDIMENTO REFERÊNCIA
		  --O MESMO SERVIÇO DO ATENDIMENTO ANTIGO(OLD)
		  --SE SIM DEIXAR A ATUALIZAÇÃO ACONTECER SENÃO
		  --VERIFICAR SE A NOVA REFERÊNCIA JA EXISTE PARA UM OUTRO REGISTRO NO ARQUIVO SE JA EXISTIR CANCELAR A OPERAÇÃO DE ATUALIZAÇÃO
		  --SENÃO PROSSEGUIR COM A MESMA

		  IF(OBJPESSOAFISICANOVO.COD<>OBJPESSOAFISICAANTIGO.COD) THEN

				   SELECT COUNT(TC.REF_CLIENTE.COD) INTO QTDREFERENCIAPF FROM TB_CLIENTE TC
				   WHERE TC.REF_CLIENTE.COD=OBJPESSOAFISICANOVO.COD;
			  IF(QTDREFERENCIAPF IS NOT NULL) THEN
				   IF(QTDREFERENCIAPF>0) THEN
					   RAISE_APPLICATION_ERROR('-20099','IMPOSSÍVEL ALTERAR CLIENTE
							POIS JÁ EXISTE OUTRO CLIENTE RELACIONADO A PESSOA FÍSICA INFORMADA!');
				   END IF;
			  END IF;
		  END IF;

   END IF;

COMMIT;
END TRG_GRANT_UM_P_UM_CLI_PESFIS;

/

--TRIGGUER PARA GARANTIR QUE EXISTA APENAS UMA REFERÊNCIA ENTRE A TABELA CLIENTE E A TABELA PESSOA JURIDICA
--TANTO NA INSERÇÃO QUANTO NA ATUALIZAÇÃO DA TABELA CLIENTE INDICANDO QUE SO PODE EXISTIR UMA REFERÊNCIA DE
--PESSOA JURIDICA PARA UM DETERMINADO CLIENTE DO CARTÓRIO

CREATE OR REPLACE TRIGGER TRG_GRANT_UM_P_UM_CLI_PESJUR
BEFORE INSERT OR UPDATE
ON TB_CLIENTE
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
DECLARE
PRAGMA AUTONOMOUS_TRANSACTION;

QTDREFERENCIAPJ NUMBER;
OBJPESSOAJURIDICA TP_PESSOA;
OBJPESSOAJURIDICANOVO TP_PESSOA;
OBJPESSOAJURIDICAANTIGO TP_PESSOA;

BEGIN


   IF(INSERTING) THEN

		  UTL_REF.SELECT_OBJECT(:NEW.REF_CLIENTE, OBJPESSOAJURIDICA);

		  --AO INSERIR UM CLIENTE NO CARTORIO VERIFICAR SE JÁ EXISTE PESSOA JURIDICA QUE REFERENCIA O CLIENTE INFORMADO
		  --SE JÁ EXISTIR CANCELAR A INSERÇÃO

		  --VAI BUSCAR NAS DUAS TABELAS REF_CLIENTE SE REFERE TANTO A PESSOA JURIDICA COMO FISICA AUMENTA O PODER DE CONSULTA
		  --OBJETO RELACIONAL É O BICHO
		  --SELECT COUNT(TC.REF_CLIENTE.COD)  FROM TB_CLIENTE TC

		  SELECT COUNT(TC.REF_CLIENTE.COD) INTO QTDREFERENCIAPJ FROM TB_CLIENTE TC WHERE
		  TC.REF_CLIENTE.COD=OBJPESSOAJURIDICA.COD;

		IF(QTDREFERENCIAPJ IS NOT NULL) THEN
		  IF(QTDREFERENCIAPJ>0) THEN
			 RAISE_APPLICATION_ERROR('-20011','IMPOSSÍVEL CADASTRAR CLIENTE
			 POIS JÁ EXISTE CLIENTE RELACIONADO A PESSOA JURÍDICA INFORMADA!');
		  END IF;
		END IF;
   END IF;

   IF(UPDATING) THEN

		   UTL_REF.SELECT_OBJECT(:NEW.REF_CLIENTE, OBJPESSOAJURIDICANOVO);
		   UTL_REF.SELECT_OBJECT(:OLD.REF_CLIENTE, OBJPESSOAJURIDICAANTIGO);

		  --AO ATUALIZAR UM CLIENTE VERIFICAR SE A NOVA REFERÊNCIA A PESSOA FISICA REFERÊNCIA
		  --O MESMO CLIENTE
		  --SE SIM DEIXAR A ATUALIZAÇÃO ACONTECER SENÃO
		  --VERIFICAR SE A NOVA REFERÊNCIA JA EXISTE PARA UM OUTRO CLIENTE SE JA EXISTIR CANCELAR A OPERAÇÃO DE ATUALIZAÇÃO
		  --SENÃO PROSSEGUIR COM A MESMA

		  IF(OBJPESSOAJURIDICANOVO.COD<>OBJPESSOAJURIDICAANTIGO.COD) THEN

				   SELECT COUNT(TC.REF_CLIENTE.COD) INTO QTDREFERENCIAPJ FROM TB_CLIENTE TC
				   WHERE TC.REF_CLIENTE.COD=OBJPESSOAJURIDICANOVO.COD;
				IF(QTDREFERENCIAPJ IS NOT NULL) THEN
				   IF(QTDREFERENCIAPJ>0) THEN
					   RAISE_APPLICATION_ERROR('-20010','IMPOSSÍVEL ALTERAR CLIENTE
							POIS JÁ EXISTE OUTRO CLIENTE RELACIONADO A PESSOA JURÍDICA INFORMADA!');
				   END IF;
				END IF;
		  END IF;

   END IF;


COMMIT;
END TRG_GRANT_UM_P_UM_CLI_PESJUR;

/

-- CRIAÇÃO DE PROCEDIMENTO ÚTIL PARA INSERIR FOTOS (BLOB) NA TABELA PASSANDO O CAMINHO DO ARQUIVO DA FOTO E O NOME DA FOTO;

CREATE OR REPLACE PROCEDURE INSERIRPFCOMFOTO(NOMEPF IN VARCHAR2, TELEFONES IN ARRAY_TELEFONE, ENDERECO IN TP_ENDERECO, CPF IN VARCHAR2, SEXO IN CHAR, DIRETORIO IN VARCHAR2 , NOMEFOTO IN VARCHAR2)IS
  L_BLOB BLOB;
  V_SRC_LOC  BFILE;
  V_AMOUNT   INTEGER;
BEGIN

  EXECUTE IMMEDIATE 'CREATE OR REPLACE DIRECTORY IMAGE_FILES AS '||CHR(39)||DIRETORIO||CHR(39);
  --COMMIT;

  V_SRC_LOC := BFILENAME('IMAGE_FILES', NOMEFOTO);

  INSERT INTO TB_FISICA VALUES(TP_FISICA(SEQ_PESSOA.NEXTVAL,NOMEPF,TELEFONES,ENDERECO,CPF,SEXO,EMPTY_BLOB()))
  RETURN FOTO INTO L_BLOB;

  DBMS_LOB.OPEN(V_SRC_LOC, DBMS_LOB.LOB_READONLY);

  V_AMOUNT := DBMS_LOB.GETLENGTH(V_SRC_LOC);
  DBMS_LOB.LOADFROMFILE(L_BLOB, V_SRC_LOC, V_AMOUNT);

  DBMS_LOB.CLOSE(V_SRC_LOC);

  COMMIT;

  DBMS_OUTPUT.PUT_LINE('SUCESSO AO INSERIR PESSOA FISICA COM FOTO!');

  EXCEPTION
  WHEN OTHERS THEN
	 DBMS_OUTPUT.PUT_LINE('ERRO AO INSERIR PESSOA FISICA COM FOTO! INFORME UMA FOTO VÁLIDA E UM
	 CAMINHO VÁLIDO PARA A FOTO DA PESSOA FÍSICA A SER CADASTRADA.');
  ROLLBACK;
END INSERIRPFCOMFOTO;